
Rtos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000021c0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000007a  00800060  000021c0  00002254  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000046e  008000da  008000da  000022ce  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000022ce  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002300  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000410  00000000  00000000  0000233c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000052ad  00000000  00000000  0000274c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000156d  00000000  00000000  000079f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002db1  00000000  00000000  00008f66  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ab4  00000000  00000000  0000bd18  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c69  00000000  00000000  0000c7cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004171  00000000  00000000  0000e435  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000360  00000000  00000000  000125a6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 83 08 	jmp	0x1106	; 0x1106 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 bd 05 	jmp	0xb7a	; 0xb7a <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ec       	ldi	r30, 0xC0	; 192
      68:	f1 e2       	ldi	r31, 0x21	; 33
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 3d       	cpi	r26, 0xDA	; 218
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	aa ed       	ldi	r26, 0xDA	; 218
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 34       	cpi	r26, 0x48	; 72
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 2a 02 	call	0x454	; 0x454 <main>
      8a:	0c 94 de 10 	jmp	0x21bc	; 0x21bc <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <vAppInitCode>:

/* CONTAIN ALL INITILZATION FOR MODULES */
void vAppInitCode( void * pvParameters )
{
	
    PORT_voidInit(); // INITILIZE PORT (ALL PINS DIRECTION AND MODE)
      92:	0e 94 c1 06 	call	0xd82	; 0xd82 <PORT_voidInit>
    ADC_voidInit();  // INITILIZE ADC
      96:	0e 94 88 05 	call	0xb10	; 0xb10 <ADC_voidInit>
	ADC_enum_setCallBack(vADCCallBack); // SET CALL BACK
      9a:	8a ed       	ldi	r24, 0xDA	; 218
      9c:	90 e0       	ldi	r25, 0x00	; 0
      9e:	0e 94 a1 05 	call	0xb42	; 0xb42 <ADC_enum_setCallBack>
	gl_kpbuff[KP_TENTH_POS] = KP_TENTH_INIT; // INIT VALUE FOR DESIRED TEMP
      a2:	e6 ee       	ldi	r30, 0xE6	; 230
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	82 e0       	ldi	r24, 0x02	; 2
      a8:	80 83       	st	Z, r24
	gl_kpbuff[KP_UNIT_POS]  = KP_UNIT_INIT;
      aa:	87 e0       	ldi	r24, 0x07	; 7
      ac:	81 83       	std	Z+1, r24	; 0x01
	
	
	LCD_API_STATE_t loc_enu_LCD_state  = LCD_API_WAITING;  // LOC FOR LCD INIT STATE
	LCD_API_STATE_t loc_enu_LCD_create = LCD_API_WAITING;  // LOC FOR LCD CREATE CUSTOM CHAR STATE
      ae:	d1 e0       	ldi	r29, 0x01	; 1
	ADC_enum_setCallBack(vADCCallBack); // SET CALL BACK
	gl_kpbuff[KP_TENTH_POS] = KP_TENTH_INIT; // INIT VALUE FOR DESIRED TEMP
	gl_kpbuff[KP_UNIT_POS]  = KP_UNIT_INIT;
	
	
	LCD_API_STATE_t loc_enu_LCD_state  = LCD_API_WAITING;  // LOC FOR LCD INIT STATE
      b0:	c1 e0       	ldi	r28, 0x01	; 1
	LCD_API_STATE_t loc_enu_LCD_create = LCD_API_WAITING;  // LOC FOR LCD CREATE CUSTOM CHAR STATE
	LCD_API_STATE_t loc_enu_LCD_send   = LCD_API_WAITING;  // LOC FOR LCD SENDING STATE
    for( ;; )
    {
		// CHECK IF LCD INIT IS DONE
		if (loc_enu_LCD_state  != LCD_API_JOB_DONE)
      b2:	cc 23       	and	r28, r28
      b4:	21 f0       	breq	.+8      	; 0xbe <vAppInitCode+0x2c>
		{
			// CALL IT UNTIL IT RETURNS JOB DONE
			loc_enu_LCD_state = LCD_enu_InitWithOs();
      b6:	0e 94 7d 03 	call	0x6fa	; 0x6fa <LCD_enu_InitWithOs>
      ba:	c8 2f       	mov	r28, r24
      bc:	0f c0       	rjmp	.+30     	; 0xdc <vAppInitCode+0x4a>
		}
		else // CASE LCD INITILIZED 
		{
			
			// CHECK IF LCD CREATE CUSTOM IS DONE
			if (loc_enu_LCD_create != LCD_API_JOB_DONE)
      be:	dd 23       	and	r29, r29
      c0:	39 f0       	breq	.+14     	; 0xd0 <vAppInitCode+0x3e>
			{
				// CALL IT UNTIL IT RETURNS JOB DONE
				loc_enu_LCD_create = LCD_CreateCustomCharacter(gl_customCelsius,CELSIUIS_INDEX);
      c2:	65 e0       	ldi	r22, 0x05	; 5
      c4:	80 e7       	ldi	r24, 0x70	; 112
      c6:	90 e0       	ldi	r25, 0x00	; 0
      c8:	0e 94 bc 04 	call	0x978	; 0x978 <LCD_CreateCustomCharacter>
      cc:	d8 2f       	mov	r29, r24
      ce:	06 c0       	rjmp	.+12     	; 0xdc <vAppInitCode+0x4a>
			}
			else // CASE CREATED 
			{
				// DELETE THIS TASK
			    vTaskDelete(xAppInitHandle);
      d0:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <xAppInitHandle>
      d4:	90 91 e5 00 	lds	r25, 0x00E5	; 0x8000e5 <xAppInitHandle+0x1>
      d8:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <vTaskDelete>
				
			}
			
		}
		
		vTaskDelay(5); // 5 MILLI FOR LCD DELAYS
      dc:	85 e0       	ldi	r24, 0x05	; 5
      de:	90 e0       	ldi	r25, 0x00	; 0
      e0:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <vTaskDelay>
    }
      e4:	e6 cf       	rjmp	.-52     	; 0xb2 <vAppInitCode+0x20>

000000e6 <vKPCode>:
{
	
	KEYPAD_enu_PressedKey_t key             = KEY_NOTHING;  // INITILALLY KEY IS NOTHING
	u8                      loc_buffcounter = FALSE;        // BUFF TRACKER OR COUNTER
	
	vTaskDelay(200); // FIRST DELAY TO MAKE SURE MODULES IS INITIALIZED
      e6:	88 ec       	ldi	r24, 0xC8	; 200
      e8:	90 e0       	ldi	r25, 0x00	; 0
      ea:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <vTaskDelay>
/* CONTAIN KEYPAD WORKING MECHANISM */
void vKPCode( void * pvParameters )
{
	
	KEYPAD_enu_PressedKey_t key             = KEY_NOTHING;  // INITILALLY KEY IS NOTHING
	u8                      loc_buffcounter = FALSE;        // BUFF TRACKER OR COUNTER
      ee:	10 e0       	ldi	r17, 0x00	; 0
	
	vTaskDelay(200); // FIRST DELAY TO MAKE SURE MODULES IS INITIALIZED
	for( ;; )
	{
		
		key = KEYPAD_GetKey(); // CHECK KEY
      f0:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <KEYPAD_GetKey>
		if(key != KEY_NOTHING) // IF SOMTHING PRESSED
      f4:	80 31       	cpi	r24, 0x10	; 16
      f6:	09 f4       	brne	.+2      	; 0xfa <vKPCode+0x14>
      f8:	58 c0       	rjmp	.+176    	; 0x1aa <vKPCode+0xc4>
		{
			// CASE NON NUMBERS KEY
			if (glkeys_[key] == 'c')
      fa:	c8 2f       	mov	r28, r24
      fc:	d0 e0       	ldi	r29, 0x00	; 0
      fe:	fe 01       	movw	r30, r28
     100:	e0 5a       	subi	r30, 0xA0	; 160
     102:	ff 4f       	sbci	r31, 0xFF	; 255
     104:	80 81       	ld	r24, Z
     106:	83 36       	cpi	r24, 0x63	; 99
     108:	e1 f4       	brne	.+56     	; 0x142 <vKPCode+0x5c>
			{
				// ASK FOR SEMAPHOR
				xSemaphoreTake(xSemaphore,SEMAPHOR_WAITING_TICKS);
     10a:	20 e0       	ldi	r18, 0x00	; 0
     10c:	42 e3       	ldi	r20, 0x32	; 50
     10e:	50 e0       	ldi	r21, 0x00	; 0
     110:	60 e0       	ldi	r22, 0x00	; 0
     112:	70 e0       	ldi	r23, 0x00	; 0
     114:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     118:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     11c:	0e 94 3a 0a 	call	0x1474	; 0x1474 <xQueueGenericReceive>
				gl_kpbuff[KP_TENTH_POS] = FALSE;//CLEAR
     120:	e6 ee       	ldi	r30, 0xE6	; 230
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	10 82       	st	Z, r1
				gl_kpbuff[KP_UNIT_POS]  = FALSE;//CLEAR
     126:	11 82       	std	Z+1, r1	; 0x01
				xSemaphoreGive(xSemaphore);
     128:	20 e0       	ldi	r18, 0x00	; 0
     12a:	40 e0       	ldi	r20, 0x00	; 0
     12c:	50 e0       	ldi	r21, 0x00	; 0
     12e:	60 e0       	ldi	r22, 0x00	; 0
     130:	70 e0       	ldi	r23, 0x00	; 0
     132:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     136:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     13a:	0e 94 af 09 	call	0x135e	; 0x135e <xQueueGenericSend>
				loc_buffcounter         = FALSE ; // CLEAR LOCAL BUFF TRACKER
     13e:	10 e0       	ldi	r17, 0x00	; 0
     140:	34 c0       	rjmp	.+104    	; 0x1aa <vKPCode+0xc4>
			}
			// CASE EQUALL KEY
			else if (glkeys_[key]=='e')
     142:	85 36       	cpi	r24, 0x65	; 101
     144:	91 f1       	breq	.+100    	; 0x1aa <vKPCode+0xc4>
				// DO NOTHING
			}
			else // CASE NUMBER
			{
				// ASK FOR SEMAPHOR
				xSemaphoreTake(xSemaphore,SEMAPHOR_WAITING_TICKS);
     146:	20 e0       	ldi	r18, 0x00	; 0
     148:	42 e3       	ldi	r20, 0x32	; 50
     14a:	50 e0       	ldi	r21, 0x00	; 0
     14c:	60 e0       	ldi	r22, 0x00	; 0
     14e:	70 e0       	ldi	r23, 0x00	; 0
     150:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     154:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     158:	0e 94 3a 0a 	call	0x1474	; 0x1474 <xQueueGenericReceive>
				gl_kpbuff[loc_buffcounter++] = glkeys_[key]; // STORE PRESSED KEY IN KP BUFF IN INDEX BUFF TRACKER
     15c:	01 e0       	ldi	r16, 0x01	; 1
     15e:	01 0f       	add	r16, r17
     160:	e1 2f       	mov	r30, r17
     162:	f0 e0       	ldi	r31, 0x00	; 0
     164:	c0 5a       	subi	r28, 0xA0	; 160
     166:	df 4f       	sbci	r29, 0xFF	; 255
     168:	88 81       	ld	r24, Y
     16a:	a6 ee       	ldi	r26, 0xE6	; 230
     16c:	b0 e0       	ldi	r27, 0x00	; 0
     16e:	ea 51       	subi	r30, 0x1A	; 26
     170:	ff 4f       	sbci	r31, 0xFF	; 255
     172:	80 83       	st	Z, r24
				gl_Desired_InitValue         = gl_kpbuff[KP_TENTH_POS]*10+gl_kpbuff[KP_UNIT_POS]; // STORE DESIRED TEMP FROM KEYS
     174:	8c 91       	ld	r24, X
     176:	11 96       	adiw	r26, 0x01	; 1
     178:	9c 91       	ld	r25, X
     17a:	88 0f       	add	r24, r24
     17c:	28 2f       	mov	r18, r24
     17e:	22 0f       	add	r18, r18
     180:	22 0f       	add	r18, r18
     182:	82 0f       	add	r24, r18
     184:	89 0f       	add	r24, r25
     186:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <gl_Desired_InitValue>
				xSemaphoreGive(xSemaphore);
     18a:	20 e0       	ldi	r18, 0x00	; 0
     18c:	40 e0       	ldi	r20, 0x00	; 0
     18e:	50 e0       	ldi	r21, 0x00	; 0
     190:	60 e0       	ldi	r22, 0x00	; 0
     192:	70 e0       	ldi	r23, 0x00	; 0
     194:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     198:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     19c:	0e 94 af 09 	call	0x135e	; 0x135e <xQueueGenericSend>
				if (loc_buffcounter == KP_MAX_INDEX) // IF TWO NUMBERS HAD ENTERD CLEAR INDEX 
     1a0:	02 30       	cpi	r16, 0x02	; 2
     1a2:	11 f0       	breq	.+4      	; 0x1a8 <vKPCode+0xc2>
			}
			else // CASE NUMBER
			{
				// ASK FOR SEMAPHOR
				xSemaphoreTake(xSemaphore,SEMAPHOR_WAITING_TICKS);
				gl_kpbuff[loc_buffcounter++] = glkeys_[key]; // STORE PRESSED KEY IN KP BUFF IN INDEX BUFF TRACKER
     1a4:	10 2f       	mov	r17, r16
     1a6:	01 c0       	rjmp	.+2      	; 0x1aa <vKPCode+0xc4>
				gl_Desired_InitValue         = gl_kpbuff[KP_TENTH_POS]*10+gl_kpbuff[KP_UNIT_POS]; // STORE DESIRED TEMP FROM KEYS
				xSemaphoreGive(xSemaphore);
				if (loc_buffcounter == KP_MAX_INDEX) // IF TWO NUMBERS HAD ENTERD CLEAR INDEX 
				{
					loc_buffcounter = FALSE ;
     1a8:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}
		
		vTaskDelay(150);
     1aa:	86 e9       	ldi	r24, 0x96	; 150
     1ac:	90 e0       	ldi	r25, 0x00	; 0
     1ae:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <vTaskDelay>
	}
     1b2:	9e cf       	rjmp	.-196    	; 0xf0 <vKPCode+0xa>

000001b4 <vADCCallBack>:



void vADCCallBack(u16 read)
{
	gl_Adc_Reading = (read*5.0)/1024*100;// CONVERT READING TO TEMP
     1b4:	bc 01       	movw	r22, r24
     1b6:	80 e0       	ldi	r24, 0x00	; 0
     1b8:	90 e0       	ldi	r25, 0x00	; 0
     1ba:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <__floatunsisf>
     1be:	20 e0       	ldi	r18, 0x00	; 0
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 ea       	ldi	r20, 0xA0	; 160
     1c4:	50 e4       	ldi	r21, 0x40	; 64
     1c6:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <__mulsf3>
     1ca:	20 e0       	ldi	r18, 0x00	; 0
     1cc:	30 e0       	ldi	r19, 0x00	; 0
     1ce:	40 e8       	ldi	r20, 0x80	; 128
     1d0:	5a e3       	ldi	r21, 0x3A	; 58
     1d2:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <__mulsf3>
     1d6:	20 e0       	ldi	r18, 0x00	; 0
     1d8:	30 e0       	ldi	r19, 0x00	; 0
     1da:	48 ec       	ldi	r20, 0xC8	; 200
     1dc:	52 e4       	ldi	r21, 0x42	; 66
     1de:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <__mulsf3>
     1e2:	0e 94 54 0f 	call	0x1ea8	; 0x1ea8 <__fixunssfsi>
     1e6:	70 93 ec 00 	sts	0x00EC, r23	; 0x8000ec <gl_Adc_Reading+0x1>
     1ea:	60 93 eb 00 	sts	0x00EB, r22	; 0x8000eb <gl_Adc_Reading>
	xQueueSend( xQueue1,( void * ) &gl_Adc_Reading,0); // SEND CONVERTED VALUE IN QUEUE
     1ee:	20 e0       	ldi	r18, 0x00	; 0
     1f0:	40 e0       	ldi	r20, 0x00	; 0
     1f2:	50 e0       	ldi	r21, 0x00	; 0
     1f4:	6b ee       	ldi	r22, 0xEB	; 235
     1f6:	70 e0       	ldi	r23, 0x00	; 0
     1f8:	80 91 dc 00 	lds	r24, 0x00DC	; 0x8000dc <xQueue1>
     1fc:	90 91 dd 00 	lds	r25, 0x00DD	; 0x8000dd <xQueue1+0x1>
     200:	0e 94 af 09 	call	0x135e	; 0x135e <xQueueGenericSend>
	gl_Adc_DONE    = FALSE; // FLAG INDICATE ADC IS DONE
     204:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <gl_Adc_DONE>
     208:	08 95       	ret

0000020a <vLcdControllerCode>:
}


/* CONTAIN LCD WORKING MECHANISM */
void vLcdControllerCode( void * pvParameters )
{
     20a:	cf 93       	push	r28
     20c:	df 93       	push	r29
     20e:	1f 92       	push	r1
     210:	cd b7       	in	r28, 0x3d	; 61
     212:	de b7       	in	r29, 0x3e	; 62
	
	
	u8 LCD_state = LCD_STATE_STRINGS; // INIT STATE IS WRITING STATIC STRINGS ON LCD 4
	u8 TEMP_BUFF = FALSE;             // STORE TEMP VALUE
     214:	19 82       	std	Y+1, r1	; 0x01
	LCD_API_STATE_t loc_enu_LCD_state  = LCD_API_WAITING;// LOCALS TO STORE STATE OF CALLED FUNCTION
	LCD_API_STATE_t loc_enu_LCD_num    = LCD_API_WAITING;// LOCALS TO STORE STATE OF WRITE NUM FUNCTION
	LCD_API_STATE_t loc_enu_LCD_XY     = LCD_API_WAITING;// LOCALS TO STORE STATE OF GOTOXY FUNCTION
	LCD_API_STATE_t loc_enu_LCD_KP     = LCD_API_WAITING;// LOCALS TO STORE STATE OF PRESSED KP
	
	vTaskDelay(200); // FIRST DELAY TO MAKE SURE MODULES IS INITIALIZED
     216:	88 ec       	ldi	r24, 0xC8	; 200
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <vTaskDelay>
	u8 TEMP_BUFF = FALSE;             // STORE TEMP VALUE
	u8 TEMP_LOCK = FALSE;             // LOCK TO NOT OVERWRITE READ
	LCD_API_STATE_t loc_enu_LCD_state  = LCD_API_WAITING;// LOCALS TO STORE STATE OF CALLED FUNCTION
	LCD_API_STATE_t loc_enu_LCD_num    = LCD_API_WAITING;// LOCALS TO STORE STATE OF WRITE NUM FUNCTION
	LCD_API_STATE_t loc_enu_LCD_XY     = LCD_API_WAITING;// LOCALS TO STORE STATE OF GOTOXY FUNCTION
	LCD_API_STATE_t loc_enu_LCD_KP     = LCD_API_WAITING;// LOCALS TO STORE STATE OF PRESSED KP
     21e:	ee 24       	eor	r14, r14
     220:	e3 94       	inc	r14
	u8 LCD_state = LCD_STATE_STRINGS; // INIT STATE IS WRITING STATIC STRINGS ON LCD 4
	u8 TEMP_BUFF = FALSE;             // STORE TEMP VALUE
	u8 TEMP_LOCK = FALSE;             // LOCK TO NOT OVERWRITE READ
	LCD_API_STATE_t loc_enu_LCD_state  = LCD_API_WAITING;// LOCALS TO STORE STATE OF CALLED FUNCTION
	LCD_API_STATE_t loc_enu_LCD_num    = LCD_API_WAITING;// LOCALS TO STORE STATE OF WRITE NUM FUNCTION
	LCD_API_STATE_t loc_enu_LCD_XY     = LCD_API_WAITING;// LOCALS TO STORE STATE OF GOTOXY FUNCTION
     222:	ff 24       	eor	r15, r15
     224:	f3 94       	inc	r15
	
	u8 LCD_state = LCD_STATE_STRINGS; // INIT STATE IS WRITING STATIC STRINGS ON LCD 4
	u8 TEMP_BUFF = FALSE;             // STORE TEMP VALUE
	u8 TEMP_LOCK = FALSE;             // LOCK TO NOT OVERWRITE READ
	LCD_API_STATE_t loc_enu_LCD_state  = LCD_API_WAITING;// LOCALS TO STORE STATE OF CALLED FUNCTION
	LCD_API_STATE_t loc_enu_LCD_num    = LCD_API_WAITING;// LOCALS TO STORE STATE OF WRITE NUM FUNCTION
     226:	dd 24       	eor	r13, r13
     228:	d3 94       	inc	r13
	
	
	u8 LCD_state = LCD_STATE_STRINGS; // INIT STATE IS WRITING STATIC STRINGS ON LCD 4
	u8 TEMP_BUFF = FALSE;             // STORE TEMP VALUE
	u8 TEMP_LOCK = FALSE;             // LOCK TO NOT OVERWRITE READ
	LCD_API_STATE_t loc_enu_LCD_state  = LCD_API_WAITING;// LOCALS TO STORE STATE OF CALLED FUNCTION
     22a:	01 e0       	ldi	r16, 0x01	; 1
{
	
	
	u8 LCD_state = LCD_STATE_STRINGS; // INIT STATE IS WRITING STATIC STRINGS ON LCD 4
	u8 TEMP_BUFF = FALSE;             // STORE TEMP VALUE
	u8 TEMP_LOCK = FALSE;             // LOCK TO NOT OVERWRITE READ
     22c:	c1 2c       	mov	r12, r1
/* CONTAIN LCD WORKING MECHANISM */
void vLcdControllerCode( void * pvParameters )
{
	
	
	u8 LCD_state = LCD_STATE_STRINGS; // INIT STATE IS WRITING STATIC STRINGS ON LCD 4
     22e:	10 e0       	ldi	r17, 0x00	; 0
	
	vTaskDelay(200); // FIRST DELAY TO MAKE SURE MODULES IS INITIALIZED
	for(;;)
	{
	    
		if (LCD_state == LCD_STATE_STRINGS) // FIRST TIME ONLY
     230:	11 11       	cpse	r17, r1
     232:	19 c0       	rjmp	.+50     	; 0x266 <vLcdControllerCode+0x5c>
		{
			// CHECK ON WRITING STRING ON LCD
			if (loc_enu_LCD_state != LCD_API_JOB_DONE)
     234:	00 23       	and	r16, r16
     236:	31 f0       	breq	.+12     	; 0x244 <vLcdControllerCode+0x3a>
			{
				// RETURN JOB DONE IF STRING IS WROTE SUCCESSFULLY
				loc_enu_LCD_state = LCD_writeString("TEMP AT ROOM : ");
     238:	88 e8       	ldi	r24, 0x88	; 136
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	0e 94 b6 03 	call	0x76c	; 0x76c <LCD_writeString>
     240:	08 2f       	mov	r16, r24
     242:	b7 c0       	rjmp	.+366    	; 0x3b2 <vLcdControllerCode+0x1a8>
			}
			else
			{
				// CHECK ON MOVING CURSOR ON LCD
				if (loc_enu_LCD_XY != LCD_API_JOB_DONE)
     244:	ff 20       	and	r15, r15
     246:	31 f0       	breq	.+12     	; 0x254 <vLcdControllerCode+0x4a>
				{
					// RETURN JOB DONE IF CURSOR MOVED SUCCESSFULLY
					loc_enu_LCD_XY = LCD_GoToXY(2,0);
     248:	60 e0       	ldi	r22, 0x00	; 0
     24a:	82 e0       	ldi	r24, 0x02	; 2
     24c:	0e 94 20 05 	call	0xa40	; 0xa40 <LCD_GoToXY>
     250:	f8 2e       	mov	r15, r24
     252:	af c0       	rjmp	.+350    	; 0x3b2 <vLcdControllerCode+0x1a8>
				}
				else
				{
					// CHECK ON WRITING STRING ON LCD FOR KP ENTERING
				    if (loc_enu_LCD_KP != LCD_API_JOB_DONE)
     254:	ee 20       	and	r14, r14
     256:	09 f4       	brne	.+2      	; 0x25a <vLcdControllerCode+0x50>
     258:	a4 c0       	rjmp	.+328    	; 0x3a2 <vLcdControllerCode+0x198>
				    {
						// RETURN JOB DONE IF STRING IS WROTE SUCCESSFULLY
					    loc_enu_LCD_KP = LCD_writeString("DESIRED TEMP : ");
     25a:	88 e9       	ldi	r24, 0x98	; 152
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	0e 94 b6 03 	call	0x76c	; 0x76c <LCD_writeString>
     262:	e8 2e       	mov	r14, r24
     264:	a6 c0       	rjmp	.+332    	; 0x3b2 <vLcdControllerCode+0x1a8>
				    }
				}
				
			}
		}
		else if (LCD_state == LCD_STATE_TEMP_READING) // LET'S CHECK ON TEMP READING TO DISPLAY
     266:	11 30       	cpi	r17, 0x01	; 1
     268:	d1 f5       	brne	.+116    	; 0x2de <vLcdControllerCode+0xd4>
		{
			
			// CHECK ON MOVING CURSOR ON LCD
			if (loc_enu_LCD_XY != LCD_API_JOB_DONE)
     26a:	ff 20       	and	r15, r15
     26c:	31 f0       	breq	.+12     	; 0x27a <vLcdControllerCode+0x70>
			{
				// RETURN JOB DONE IF CURSOR MOVED SUCCESSFULLY
				loc_enu_LCD_XY = LCD_GoToXY(0,14);
     26e:	6e e0       	ldi	r22, 0x0E	; 14
     270:	80 e0       	ldi	r24, 0x00	; 0
     272:	0e 94 20 05 	call	0xa40	; 0xa40 <LCD_GoToXY>
     276:	f8 2e       	mov	r15, r24
     278:	9c c0       	rjmp	.+312    	; 0x3b2 <vLcdControllerCode+0x1a8>
			}
			else
			{
				// CHECK IF TEMP HAS ALREADY READED
				if(TEMP_LOCK == FALSE)
     27a:	c1 10       	cpse	r12, r1
     27c:	10 c0       	rjmp	.+32     	; 0x29e <vLcdControllerCode+0x94>
				{
					// RECIEVE READING
					if( xQueueReceive( xQueue1,&( TEMP_BUFF),10 ) == pdPASS )
     27e:	20 e0       	ldi	r18, 0x00	; 0
     280:	4a e0       	ldi	r20, 0x0A	; 10
     282:	50 e0       	ldi	r21, 0x00	; 0
     284:	be 01       	movw	r22, r28
     286:	6f 5f       	subi	r22, 0xFF	; 255
     288:	7f 4f       	sbci	r23, 0xFF	; 255
     28a:	80 91 dc 00 	lds	r24, 0x00DC	; 0x8000dc <xQueue1>
     28e:	90 91 dd 00 	lds	r25, 0x00DD	; 0x8000dd <xQueue1+0x1>
     292:	0e 94 3a 0a 	call	0x1474	; 0x1474 <xQueueGenericReceive>
     296:	81 30       	cpi	r24, 0x01	; 1
     298:	11 f4       	brne	.+4      	; 0x29e <vLcdControllerCode+0x94>
					{
						// LOCK RECIVING UNTIL VALUE IS DISPLAYED
						TEMP_LOCK = TRUE;
     29a:	cc 24       	eor	r12, r12
     29c:	c3 94       	inc	r12
					}
				}
				
                // CHECK ON WRITING TEMP VALUE ON LCD
				if (loc_enu_LCD_num != LCD_API_JOB_DONE)
     29e:	dd 20       	and	r13, r13
     2a0:	41 f0       	breq	.+16     	; 0x2b2 <vLcdControllerCode+0xa8>
				{
					// RETURN JOB DONE IF NUMBER WROTE SUCCESSFULLY
					loc_enu_LCD_num = LCD_writeNumber(TEMP_BUFF);
     2a2:	69 81       	ldd	r22, Y+1	; 0x01
     2a4:	70 e0       	ldi	r23, 0x00	; 0
     2a6:	80 e0       	ldi	r24, 0x00	; 0
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_writeNumber>
     2ae:	d8 2e       	mov	r13, r24
     2b0:	80 c0       	rjmp	.+256    	; 0x3b2 <vLcdControllerCode+0x1a8>
				}
				else
				{
					// CHECK ON WRITING CUSTOM CHAR CELSIUS ON LCD
					if (loc_enu_LCD_state != LCD_API_JOB_DONE)
     2b2:	00 23       	and	r16, r16
     2b4:	31 f0       	breq	.+12     	; 0x2c2 <vLcdControllerCode+0xb8>
					{
						// RETURN JOB DONE IF CUSTOM CHAR CELSIUS WROTE SUCCESSFULLY
					   loc_enu_LCD_state = LCD_send(LCD_DATA,CELSIUIS_INDEX>>4); // SEND HIGHER NIBBLE
     2b6:	60 e0       	ldi	r22, 0x00	; 0
     2b8:	81 e0       	ldi	r24, 0x01	; 1
     2ba:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     2be:	08 2f       	mov	r16, r24
     2c0:	78 c0       	rjmp	.+240    	; 0x3b2 <vLcdControllerCode+0x1a8>

					}
					else
					{
						LCD_send(LCD_DATA,CELSIUIS_INDEX);   // SEND LOWER NIBBLE
     2c2:	65 e0       	ldi	r22, 0x05	; 5
     2c4:	81 e0       	ldi	r24, 0x01	; 1
     2c6:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
						loc_enu_LCD_num   = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_XY    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_state = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_KP    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
     2ca:	ee 24       	eor	r14, r14
     2cc:	e3 94       	inc	r14
					}
					else
					{
						LCD_send(LCD_DATA,CELSIUIS_INDEX);   // SEND LOWER NIBBLE
						loc_enu_LCD_num   = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_XY    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
     2ce:	ff 24       	eor	r15, r15
     2d0:	f3 94       	inc	r15

					}
					else
					{
						LCD_send(LCD_DATA,CELSIUIS_INDEX);   // SEND LOWER NIBBLE
						loc_enu_LCD_num   = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
     2d2:	dd 24       	eor	r13, r13
     2d4:	d3 94       	inc	r13
						loc_enu_LCD_XY    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_state = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
     2d6:	01 e0       	ldi	r16, 0x01	; 1
						loc_enu_LCD_KP    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
						TEMP_LOCK         = FALSE;           // CLEAR LOCK TO RECIEVE NEXT CYCLE
     2d8:	c1 2c       	mov	r12, r1
						LCD_state         = LCD_STATE_DESIRED_CHECK; // MOVE TO NEXT STATE
     2da:	12 e0       	ldi	r17, 0x02	; 2
     2dc:	6a c0       	rjmp	.+212    	; 0x3b2 <vLcdControllerCode+0x1a8>

				}
			}
			
		} 
		else if (LCD_state == LCD_STATE_DESIRED_CHECK) // LET'S CHECK ON DESIRED TEMP ENTERD BY KP TO DISPLAY
     2de:	12 30       	cpi	r17, 0x02	; 2
     2e0:	09 f0       	breq	.+2      	; 0x2e4 <vLcdControllerCode+0xda>
     2e2:	67 c0       	rjmp	.+206    	; 0x3b2 <vLcdControllerCode+0x1a8>
		{
			
			// CHECK ON MOVING CURSOR ON LCD
			if (loc_enu_LCD_XY != LCD_API_JOB_DONE)
     2e4:	ff 20       	and	r15, r15
     2e6:	31 f0       	breq	.+12     	; 0x2f4 <vLcdControllerCode+0xea>
			{
				// RETURN JOB DONE IF CURSOR MOVED SUCCESSFULLY
				loc_enu_LCD_XY = LCD_GoToXY(2,14);
     2e8:	6e e0       	ldi	r22, 0x0E	; 14
     2ea:	82 e0       	ldi	r24, 0x02	; 2
     2ec:	0e 94 20 05 	call	0xa40	; 0xa40 <LCD_GoToXY>
     2f0:	f8 2e       	mov	r15, r24
     2f2:	5f c0       	rjmp	.+190    	; 0x3b2 <vLcdControllerCode+0x1a8>
			}
			else
			{
				
				if (loc_enu_LCD_num != LCD_API_JOB_DONE)
     2f4:	dd 20       	and	r13, r13
     2f6:	f9 f0       	breq	.+62     	; 0x336 <vLcdControllerCode+0x12c>
				{
					// ASK FOR SEMAPHOR
					xSemaphoreTake(xSemaphore,SEMAPHOR_WAITING_TICKS);
     2f8:	20 e0       	ldi	r18, 0x00	; 0
     2fa:	42 e3       	ldi	r20, 0x32	; 50
     2fc:	50 e0       	ldi	r21, 0x00	; 0
     2fe:	60 e0       	ldi	r22, 0x00	; 0
     300:	70 e0       	ldi	r23, 0x00	; 0
     302:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     306:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     30a:	0e 94 3a 0a 	call	0x1474	; 0x1474 <xQueueGenericReceive>
					loc_enu_LCD_num = LCD_writeNumber(gl_kpbuff[KP_TENTH_POS]); // DISPLAY KP ENTERD AT TENTH POS
     30e:	60 91 e6 00 	lds	r22, 0x00E6	; 0x8000e6 <gl_kpbuff>
     312:	70 e0       	ldi	r23, 0x00	; 0
     314:	80 e0       	ldi	r24, 0x00	; 0
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_writeNumber>
     31c:	d8 2e       	mov	r13, r24
					xSemaphoreGive(xSemaphore);
     31e:	20 e0       	ldi	r18, 0x00	; 0
     320:	40 e0       	ldi	r20, 0x00	; 0
     322:	50 e0       	ldi	r21, 0x00	; 0
     324:	60 e0       	ldi	r22, 0x00	; 0
     326:	70 e0       	ldi	r23, 0x00	; 0
     328:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     32c:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     330:	0e 94 af 09 	call	0x135e	; 0x135e <xQueueGenericSend>
     334:	3e c0       	rjmp	.+124    	; 0x3b2 <vLcdControllerCode+0x1a8>
				}
				else
				{
					if (loc_enu_LCD_state != LCD_API_JOB_DONE)
     336:	00 23       	and	r16, r16
     338:	f9 f0       	breq	.+62     	; 0x378 <vLcdControllerCode+0x16e>
					{
						// ASK FOR SEMAPHOR
						xSemaphoreTake(xSemaphore,SEMAPHOR_WAITING_TICKS);
     33a:	20 e0       	ldi	r18, 0x00	; 0
     33c:	42 e3       	ldi	r20, 0x32	; 50
     33e:	50 e0       	ldi	r21, 0x00	; 0
     340:	60 e0       	ldi	r22, 0x00	; 0
     342:	70 e0       	ldi	r23, 0x00	; 0
     344:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     348:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     34c:	0e 94 3a 0a 	call	0x1474	; 0x1474 <xQueueGenericReceive>
						loc_enu_LCD_state = LCD_writeNumber(gl_kpbuff[KP_UNIT_POS]); // DISPLAY KP ENTERD AT UNIT POS
     350:	60 91 e7 00 	lds	r22, 0x00E7	; 0x8000e7 <gl_kpbuff+0x1>
     354:	70 e0       	ldi	r23, 0x00	; 0
     356:	80 e0       	ldi	r24, 0x00	; 0
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_writeNumber>
     35e:	08 2f       	mov	r16, r24
						xSemaphoreGive(xSemaphore);
     360:	20 e0       	ldi	r18, 0x00	; 0
     362:	40 e0       	ldi	r20, 0x00	; 0
     364:	50 e0       	ldi	r21, 0x00	; 0
     366:	60 e0       	ldi	r22, 0x00	; 0
     368:	70 e0       	ldi	r23, 0x00	; 0
     36a:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     36e:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     372:	0e 94 af 09 	call	0x135e	; 0x135e <xQueueGenericSend>
     376:	1d c0       	rjmp	.+58     	; 0x3b2 <vLcdControllerCode+0x1a8>
					}
					else
					{
						// CHECK ON WRITING CUSTOM CHAR CELSIUS ON LCD
						if (loc_enu_LCD_KP != LCD_API_JOB_DONE)
     378:	ee 20       	and	r14, r14
     37a:	31 f0       	breq	.+12     	; 0x388 <vLcdControllerCode+0x17e>
						{
							loc_enu_LCD_KP = LCD_send(LCD_DATA,CELSIUIS_INDEX>>4); // SEND HIGHER NIBBLE
     37c:	60 e0       	ldi	r22, 0x00	; 0
     37e:	81 e0       	ldi	r24, 0x01	; 1
     380:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     384:	e8 2e       	mov	r14, r24
     386:	15 c0       	rjmp	.+42     	; 0x3b2 <vLcdControllerCode+0x1a8>
						}
						else
						{
							LCD_send(LCD_DATA,CELSIUIS_INDEX); // SEND LOW NIBBLE
     388:	65 e0       	ldi	r22, 0x05	; 5
     38a:	81 e0       	ldi	r24, 0x01	; 1
     38c:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
							loc_enu_LCD_num   = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
							loc_enu_LCD_XY    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
							loc_enu_LCD_state = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
							loc_enu_LCD_KP    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
     390:	ee 24       	eor	r14, r14
     392:	e3 94       	inc	r14
						}
						else
						{
							LCD_send(LCD_DATA,CELSIUIS_INDEX); // SEND LOW NIBBLE
							loc_enu_LCD_num   = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
							loc_enu_LCD_XY    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
     394:	ff 24       	eor	r15, r15
     396:	f3 94       	inc	r15
							loc_enu_LCD_KP = LCD_send(LCD_DATA,CELSIUIS_INDEX>>4); // SEND HIGHER NIBBLE
						}
						else
						{
							LCD_send(LCD_DATA,CELSIUIS_INDEX); // SEND LOW NIBBLE
							loc_enu_LCD_num   = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
     398:	dd 24       	eor	r13, r13
     39a:	d3 94       	inc	r13
							loc_enu_LCD_XY    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
							loc_enu_LCD_state = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
     39c:	01 e0       	ldi	r16, 0x01	; 1
							loc_enu_LCD_KP    = LCD_API_WAITING; // CLEAR VAR TO USE IT IN NEXT STATE
							LCD_state = LCD_STATE_TEMP_READING; // MOVE TO NEXT STATE
     39e:	11 e0       	ldi	r17, 0x01	; 1
     3a0:	08 c0       	rjmp	.+16     	; 0x3b2 <vLcdControllerCode+0x1a8>
				    else // CASE EVERY THING IS DONE 
				    {
						loc_enu_LCD_num   = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_XY    = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_state = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_KP    = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
     3a2:	ee 24       	eor	r14, r14
     3a4:	e3 94       	inc	r14
					    loc_enu_LCD_KP = LCD_writeString("DESIRED TEMP : ");
				    }
				    else // CASE EVERY THING IS DONE 
				    {
						loc_enu_LCD_num   = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_XY    = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
     3a6:	ff 24       	eor	r15, r15
     3a8:	f3 94       	inc	r15
						// RETURN JOB DONE IF STRING IS WROTE SUCCESSFULLY
					    loc_enu_LCD_KP = LCD_writeString("DESIRED TEMP : ");
				    }
				    else // CASE EVERY THING IS DONE 
				    {
						loc_enu_LCD_num   = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
     3aa:	dd 24       	eor	r13, r13
     3ac:	d3 94       	inc	r13
						loc_enu_LCD_XY    = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
						loc_enu_LCD_state = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
     3ae:	01 e0       	ldi	r16, 0x01	; 1
						loc_enu_LCD_KP    = LCD_API_WAITING;// CLEAR VAR TO USE IT IN NEXT STATE
					    LCD_state         = LCD_STATE_TEMP_READING; // MOVE TO NEXT STATE
     3b0:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
			
		}
		
		vTaskDelay(5);
     3b2:	85 e0       	ldi	r24, 0x05	; 5
     3b4:	90 e0       	ldi	r25, 0x00	; 0
     3b6:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <vTaskDelay>
	}
     3ba:	3a cf       	rjmp	.-396    	; 0x230 <vLcdControllerCode+0x26>

000003bc <vAppControlCode>:
/* CONTAIN ADC AND MOTOR WORKING MECHANISM */
void vAppControlCode( void * pvParameters )
{
	
	
	vTaskDelay(200); // FIRST DELAY TO MAKE SURE ALL MODULE IS INITIALIZED
     3bc:	88 ec       	ldi	r24, 0xC8	; 200
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <vTaskDelay>
	for(;;)
	{
		
		// CHECK IF READING IS DONE
		if (gl_Adc_DONE == FALSE)
     3c4:	80 91 ea 00 	lds	r24, 0x00EA	; 0x8000ea <gl_Adc_DONE>
     3c8:	81 11       	cpse	r24, r1
     3ca:	06 c0       	rjmp	.+12     	; 0x3d8 <vAppControlCode+0x1c>
		{
			gl_Adc_DONE = TRUE ; 
     3cc:	81 e0       	ldi	r24, 0x01	; 1
     3ce:	80 93 ea 00 	sts	0x00EA, r24	; 0x8000ea <gl_Adc_DONE>
			ADC_enum_readValueInterrupt(ADC_PORTA_PIN_0); // ASK FOR NEW READING
     3d2:	80 e0       	ldi	r24, 0x00	; 0
     3d4:	0e 94 ab 05 	call	0xb56	; 0xb56 <ADC_enum_readValueInterrupt>
		}
		
		xSemaphoreTake(xSemaphore,50);
     3d8:	20 e0       	ldi	r18, 0x00	; 0
     3da:	42 e3       	ldi	r20, 0x32	; 50
     3dc:	50 e0       	ldi	r21, 0x00	; 0
     3de:	60 e0       	ldi	r22, 0x00	; 0
     3e0:	70 e0       	ldi	r23, 0x00	; 0
     3e2:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     3e6:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     3ea:	0e 94 3a 0a 	call	0x1474	; 0x1474 <xQueueGenericReceive>
		if(gl_Desired_InitValue < gl_Adc_Reading && gl_KP_DONE == FALSE) // CASE DESIRED LESS THAN READING 
     3ee:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <gl_Desired_InitValue>
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <gl_Adc_Reading>
     3f8:	30 91 ec 00 	lds	r19, 0x00EC	; 0x8000ec <gl_Adc_Reading+0x1>
     3fc:	82 17       	cp	r24, r18
     3fe:	93 07       	cpc	r25, r19
     400:	60 f4       	brcc	.+24     	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
     402:	40 91 e9 00 	lds	r20, 0x00E9	; 0x8000e9 <gl_KP_DONE>
     406:	41 11       	cpse	r20, r1
     408:	08 c0       	rjmp	.+16     	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
		{
		   DIO_enu_WriteChannel(DIO_PORTB_PIN6,DIO_PIN_LEVEL_HIGH); // ENABLE FAN
     40a:	61 e0       	ldi	r22, 0x01	; 1
     40c:	8e e0       	ldi	r24, 0x0E	; 14
     40e:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
		   gl_KP_DONE = TRUE;
     412:	81 e0       	ldi	r24, 0x01	; 1
     414:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <gl_KP_DONE>
     418:	0d c0       	rjmp	.+26     	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
		}
		else if (gl_Desired_InitValue >= gl_Adc_Reading) // CASE DESIRED IS MORE THAN OR EQUALL READING
     41a:	82 17       	cp	r24, r18
     41c:	93 07       	cpc	r25, r19
     41e:	50 f0       	brcs	.+20     	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
		{
		 
		    if (gl_KP_DONE == TRUE)
     420:	80 91 e9 00 	lds	r24, 0x00E9	; 0x8000e9 <gl_KP_DONE>
     424:	81 30       	cpi	r24, 0x01	; 1
     426:	31 f4       	brne	.+12     	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
		    {
		  	  DIO_enu_WriteChannel(DIO_PORTB_PIN6,DIO_PIN_LEVEL_LOW); //  DISABLE FAN
     428:	60 e0       	ldi	r22, 0x00	; 0
     42a:	8e e0       	ldi	r24, 0x0E	; 14
     42c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
		  	  gl_KP_DONE = FALSE;
     430:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <gl_KP_DONE>
		    }
		 
		}
		xSemaphoreGive(xSemaphore);
     434:	20 e0       	ldi	r18, 0x00	; 0
     436:	40 e0       	ldi	r20, 0x00	; 0
     438:	50 e0       	ldi	r21, 0x00	; 0
     43a:	60 e0       	ldi	r22, 0x00	; 0
     43c:	70 e0       	ldi	r23, 0x00	; 0
     43e:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     442:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     446:	0e 94 af 09 	call	0x135e	; 0x135e <xQueueGenericSend>
		vTaskDelay(100);
     44a:	84 e6       	ldi	r24, 0x64	; 100
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <vTaskDelay>
		
	}
     452:	b8 cf       	rjmp	.-144    	; 0x3c4 <vAppControlCode+0x8>

00000454 <main>:
}
int main(void)
{

	    xQueue1 = xQueueCreate( 10, sizeof( unsigned char ) );
     454:	61 e0       	ldi	r22, 0x01	; 1
     456:	8a e0       	ldi	r24, 0x0A	; 10
     458:	0e 94 4f 09 	call	0x129e	; 0x129e <xQueueCreate>
     45c:	90 93 dd 00 	sts	0x00DD, r25	; 0x8000dd <xQueue1+0x1>
     460:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <xQueue1>
		vSemaphoreCreateBinary(xSemaphore);
     464:	60 e0       	ldi	r22, 0x00	; 0
     466:	81 e0       	ldi	r24, 0x01	; 1
     468:	0e 94 4f 09 	call	0x129e	; 0x129e <xQueueCreate>
     46c:	90 93 db 00 	sts	0x00DB, r25	; 0x8000db <__data_end+0x1>
     470:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <__data_end>
     474:	00 97       	sbiw	r24, 0x00	; 0
     476:	39 f0       	breq	.+14     	; 0x486 <main+0x32>
     478:	20 e0       	ldi	r18, 0x00	; 0
     47a:	40 e0       	ldi	r20, 0x00	; 0
     47c:	50 e0       	ldi	r21, 0x00	; 0
     47e:	60 e0       	ldi	r22, 0x00	; 0
     480:	70 e0       	ldi	r23, 0x00	; 0
     482:	0e 94 af 09 	call	0x135e	; 0x135e <xQueueGenericSend>
	    /* Create the task, storing the handle. */
	    xTaskCreate(
     486:	a1 2c       	mov	r10, r1
     488:	b1 2c       	mov	r11, r1
     48a:	c1 2c       	mov	r12, r1
     48c:	d1 2c       	mov	r13, r1
     48e:	0f 2e       	mov	r0, r31
     490:	f4 ee       	ldi	r31, 0xE4	; 228
     492:	ef 2e       	mov	r14, r31
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	ff 2e       	mov	r15, r31
     498:	f0 2d       	mov	r31, r0
     49a:	04 e0       	ldi	r16, 0x04	; 4
     49c:	20 e0       	ldi	r18, 0x00	; 0
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	45 e5       	ldi	r20, 0x55	; 85
     4a2:	50 e0       	ldi	r21, 0x00	; 0
     4a4:	68 ea       	ldi	r22, 0xA8	; 168
     4a6:	70 e0       	ldi	r23, 0x00	; 0
     4a8:	89 e4       	ldi	r24, 0x49	; 73
     4aa:	90 e0       	ldi	r25, 0x00	; 0
     4ac:	0e 94 a6 0b 	call	0x174c	; 0x174c <xTaskGenericCreate>
	    PTR_NULL,    /* Parameter passed into the task. */
	    4,/* Priority at which the task is created. */
	    &xAppInitHandle );      /* Used to pass out the created task's handle. */
		
		 /* Create the task, storing the handle. */
		 xTaskCreate(
     4b0:	0f 2e       	mov	r0, r31
     4b2:	f2 ee       	ldi	r31, 0xE2	; 226
     4b4:	ef 2e       	mov	r14, r31
     4b6:	f0 e0       	ldi	r31, 0x00	; 0
     4b8:	ff 2e       	mov	r15, r31
     4ba:	f0 2d       	mov	r31, r0
     4bc:	01 e0       	ldi	r16, 0x01	; 1
     4be:	20 e0       	ldi	r18, 0x00	; 0
     4c0:	30 e0       	ldi	r19, 0x00	; 0
     4c2:	40 e8       	ldi	r20, 0x80	; 128
     4c4:	50 e0       	ldi	r21, 0x00	; 0
     4c6:	61 eb       	ldi	r22, 0xB1	; 177
     4c8:	70 e0       	ldi	r23, 0x00	; 0
     4ca:	85 e0       	ldi	r24, 0x05	; 5
     4cc:	91 e0       	ldi	r25, 0x01	; 1
     4ce:	0e 94 a6 0b 	call	0x174c	; 0x174c <xTaskGenericCreate>
		 PTR_NULL,    /* Parameter passed into the task. */
		 1,/* Priority at which the task is created. */
		 &xLcdControllerHandle );      /* Used to pass out the created task's handle. */
		 
		  /* Create the task, storing the handle. */
		  xTaskCreate(
     4d2:	0f 2e       	mov	r0, r31
     4d4:	f0 ee       	ldi	r31, 0xE0	; 224
     4d6:	ef 2e       	mov	r14, r31
     4d8:	f0 e0       	ldi	r31, 0x00	; 0
     4da:	ff 2e       	mov	r15, r31
     4dc:	f0 2d       	mov	r31, r0
     4de:	02 e0       	ldi	r16, 0x02	; 2
     4e0:	20 e0       	ldi	r18, 0x00	; 0
     4e2:	30 e0       	ldi	r19, 0x00	; 0
     4e4:	40 e8       	ldi	r20, 0x80	; 128
     4e6:	50 e0       	ldi	r21, 0x00	; 0
     4e8:	6d eb       	ldi	r22, 0xBD	; 189
     4ea:	70 e0       	ldi	r23, 0x00	; 0
     4ec:	8e ed       	ldi	r24, 0xDE	; 222
     4ee:	91 e0       	ldi	r25, 0x01	; 1
     4f0:	0e 94 a6 0b 	call	0x174c	; 0x174c <xTaskGenericCreate>
		  PTR_NULL,    /* Parameter passed into the task. */
		  2,/* Priority at which the task is created. */
		  &xAppControlHandle );      /* Used to pass out the created task's handle. */
		  
		    /* Create the task, storing the handle. */
		    xTaskCreate(
     4f4:	0f 2e       	mov	r0, r31
     4f6:	fe ed       	ldi	r31, 0xDE	; 222
     4f8:	ef 2e       	mov	r14, r31
     4fa:	f0 e0       	ldi	r31, 0x00	; 0
     4fc:	ff 2e       	mov	r15, r31
     4fe:	f0 2d       	mov	r31, r0
     500:	20 e0       	ldi	r18, 0x00	; 0
     502:	30 e0       	ldi	r19, 0x00	; 0
     504:	40 e8       	ldi	r20, 0x80	; 128
     506:	50 e0       	ldi	r21, 0x00	; 0
     508:	69 ec       	ldi	r22, 0xC9	; 201
     50a:	70 e0       	ldi	r23, 0x00	; 0
     50c:	83 e7       	ldi	r24, 0x73	; 115
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	0e 94 a6 0b 	call	0x174c	; 0x174c <xTaskGenericCreate>
		    "KP_CONTROL",          /* Text name for the task. */
		    128,      /* Stack size in words, not bytes. */
		    PTR_NULL,    /* Parameter passed into the task. */
		    2,/* Priority at which the task is created. */
		    &xKPHandle );      /* Used to pass out the created task's handle. */
		vTaskStartScheduler();
     514:	0e 94 af 0c 	call	0x195e	; 0x195e <vTaskStartScheduler>
     518:	ff cf       	rjmp	.-2      	; 0x518 <main+0xc4>

0000051a <KEYPAD_writeRows>:
#define COL_2_PATTERN    0x0B
#define COL_3_PATTERN    0x07


static void KEYPAD_writeRows(u8 arg_u8_pattern)
{
     51a:	cf 93       	push	r28
     51c:	c8 2f       	mov	r28, r24
	DIO_enu_WriteChannel(KEYPAD_ROW_0_PIN,GET_BIT(arg_u8_pattern,0));
     51e:	68 2f       	mov	r22, r24
     520:	61 70       	andi	r22, 0x01	; 1
     522:	85 e1       	ldi	r24, 0x15	; 21
     524:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
	DIO_enu_WriteChannel(KEYPAD_ROW_1_PIN,GET_BIT(arg_u8_pattern,1));
     528:	c1 fb       	bst	r28, 1
     52a:	66 27       	eor	r22, r22
     52c:	60 f9       	bld	r22, 0
     52e:	84 e1       	ldi	r24, 0x14	; 20
     530:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
	DIO_enu_WriteChannel(KEYPAD_ROW_2_PIN,GET_BIT(arg_u8_pattern,2));
     534:	c2 fb       	bst	r28, 2
     536:	66 27       	eor	r22, r22
     538:	60 f9       	bld	r22, 0
     53a:	83 e1       	ldi	r24, 0x13	; 19
     53c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
	DIO_enu_WriteChannel(KEYPAD_ROW_3_PIN,GET_BIT(arg_u8_pattern,3));
     540:	c3 fb       	bst	r28, 3
     542:	66 27       	eor	r22, r22
     544:	60 f9       	bld	r22, 0
     546:	82 e1       	ldi	r24, 0x12	; 18
     548:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
}
     54c:	cf 91       	pop	r28
     54e:	08 95       	ret

00000550 <KEYPAD_readCols>:
static void KEYPAD_readCols(u8 *arg_u8_col)
{
     550:	0f 93       	push	r16
     552:	1f 93       	push	r17
     554:	cf 93       	push	r28
     556:	df 93       	push	r29
     558:	1f 92       	push	r1
     55a:	cd b7       	in	r28, 0x3d	; 61
     55c:	de b7       	in	r29, 0x3e	; 62
     55e:	8c 01       	movw	r16, r24
	u8 loc_u8_temp = FALSE;
     560:	19 82       	std	Y+1, r1	; 0x01
	*arg_u8_col     = FALSE;
     562:	fc 01       	movw	r30, r24
     564:	10 82       	st	Z, r1
	
	DIO_enu_ReadChannel(KEYPAD_COL_0_PIN,&loc_u8_temp);
     566:	be 01       	movw	r22, r28
     568:	6f 5f       	subi	r22, 0xFF	; 255
     56a:	7f 4f       	sbci	r23, 0xFF	; 255
     56c:	8f e1       	ldi	r24, 0x1F	; 31
     56e:	0e 94 78 06 	call	0xcf0	; 0xcf0 <DIO_enu_ReadChannel>
	*arg_u8_col |= (loc_u8_temp << 0);
     572:	f8 01       	movw	r30, r16
     574:	90 81       	ld	r25, Z
     576:	89 81       	ldd	r24, Y+1	; 0x01
     578:	89 2b       	or	r24, r25
     57a:	80 83       	st	Z, r24
	
	DIO_enu_ReadChannel(KEYPAD_COL_1_PIN,&loc_u8_temp);
     57c:	be 01       	movw	r22, r28
     57e:	6f 5f       	subi	r22, 0xFF	; 255
     580:	7f 4f       	sbci	r23, 0xFF	; 255
     582:	8e e1       	ldi	r24, 0x1E	; 30
     584:	0e 94 78 06 	call	0xcf0	; 0xcf0 <DIO_enu_ReadChannel>
	*arg_u8_col |= loc_u8_temp << 1;
     588:	89 81       	ldd	r24, Y+1	; 0x01
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	88 0f       	add	r24, r24
     58e:	99 1f       	adc	r25, r25
     590:	f8 01       	movw	r30, r16
     592:	90 81       	ld	r25, Z
     594:	89 2b       	or	r24, r25
     596:	80 83       	st	Z, r24
	
	DIO_enu_ReadChannel(KEYPAD_COL_2_PIN,&loc_u8_temp);
     598:	be 01       	movw	r22, r28
     59a:	6f 5f       	subi	r22, 0xFF	; 255
     59c:	7f 4f       	sbci	r23, 0xFF	; 255
     59e:	8d e1       	ldi	r24, 0x1D	; 29
     5a0:	0e 94 78 06 	call	0xcf0	; 0xcf0 <DIO_enu_ReadChannel>
	*arg_u8_col |= loc_u8_temp << 2;
     5a4:	89 81       	ldd	r24, Y+1	; 0x01
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	88 0f       	add	r24, r24
     5aa:	99 1f       	adc	r25, r25
     5ac:	88 0f       	add	r24, r24
     5ae:	99 1f       	adc	r25, r25
     5b0:	f8 01       	movw	r30, r16
     5b2:	90 81       	ld	r25, Z
     5b4:	89 2b       	or	r24, r25
     5b6:	80 83       	st	Z, r24
	
	DIO_enu_ReadChannel(KEYPAD_COL_3_PIN,&loc_u8_temp);
     5b8:	be 01       	movw	r22, r28
     5ba:	6f 5f       	subi	r22, 0xFF	; 255
     5bc:	7f 4f       	sbci	r23, 0xFF	; 255
     5be:	8b e1       	ldi	r24, 0x1B	; 27
     5c0:	0e 94 78 06 	call	0xcf0	; 0xcf0 <DIO_enu_ReadChannel>
	*arg_u8_col |= loc_u8_temp << 3;
     5c4:	89 81       	ldd	r24, Y+1	; 0x01
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	88 0f       	add	r24, r24
     5ca:	99 1f       	adc	r25, r25
     5cc:	88 0f       	add	r24, r24
     5ce:	99 1f       	adc	r25, r25
     5d0:	88 0f       	add	r24, r24
     5d2:	99 1f       	adc	r25, r25
     5d4:	f8 01       	movw	r30, r16
     5d6:	90 81       	ld	r25, Z
     5d8:	89 2b       	or	r24, r25
     5da:	80 83       	st	Z, r24
}
     5dc:	0f 90       	pop	r0
     5de:	df 91       	pop	r29
     5e0:	cf 91       	pop	r28
     5e2:	1f 91       	pop	r17
     5e4:	0f 91       	pop	r16
     5e6:	08 95       	ret

000005e8 <KEYPAD_GetKey>:
KEYPAD_enu_PressedKey_t KEYPAD_GetKey(void)
{
     5e8:	0f 93       	push	r16
     5ea:	1f 93       	push	r17
     5ec:	cf 93       	push	r28
     5ee:	df 93       	push	r29
     5f0:	1f 92       	push	r1
     5f2:	cd b7       	in	r28, 0x3d	; 61
     5f4:	de b7       	in	r29, 0x3e	; 62
	KEYPAD_enu_PressedKey_t loc_enu_returnKey = KEY_NOTHING;
	u8                      loc_u8_itrator    = FALSE;
	u8                      loc_u8_colSelect  = FALSE;
     5f6:	19 82       	std	Y+1, r1	; 0x01
	*arg_u8_col |= loc_u8_temp << 3;
}
KEYPAD_enu_PressedKey_t KEYPAD_GetKey(void)
{
	KEYPAD_enu_PressedKey_t loc_enu_returnKey = KEY_NOTHING;
	u8                      loc_u8_itrator    = FALSE;
     5f8:	10 e0       	ldi	r17, 0x00	; 0
	DIO_enu_ReadChannel(KEYPAD_COL_3_PIN,&loc_u8_temp);
	*arg_u8_col |= loc_u8_temp << 3;
}
KEYPAD_enu_PressedKey_t KEYPAD_GetKey(void)
{
	KEYPAD_enu_PressedKey_t loc_enu_returnKey = KEY_NOTHING;
     5fa:	00 e1       	ldi	r16, 0x10	; 16
	u8                      loc_u8_itrator    = FALSE;
	u8                      loc_u8_colSelect  = FALSE;
	
	for(;loc_u8_itrator<ROWS_NUMBER;loc_u8_itrator++)
     5fc:	30 c0       	rjmp	.+96     	; 0x65e <KEYPAD_GetKey+0x76>
	{
		KEYPAD_writeRows(TGL_NO_ASSIGN(DEFAULT_PATTERN,loc_u8_itrator));
     5fe:	81 e0       	ldi	r24, 0x01	; 1
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	01 2e       	mov	r0, r17
     604:	02 c0       	rjmp	.+4      	; 0x60a <KEYPAD_GetKey+0x22>
     606:	88 0f       	add	r24, r24
     608:	99 1f       	adc	r25, r25
     60a:	0a 94       	dec	r0
     60c:	e2 f7       	brpl	.-8      	; 0x606 <KEYPAD_GetKey+0x1e>
     60e:	9f e0       	ldi	r25, 0x0F	; 15
     610:	89 27       	eor	r24, r25
     612:	0e 94 8d 02 	call	0x51a	; 0x51a <KEYPAD_writeRows>
		KEYPAD_readCols(&loc_u8_colSelect);
     616:	ce 01       	movw	r24, r28
     618:	01 96       	adiw	r24, 0x01	; 1
     61a:	0e 94 a8 02 	call	0x550	; 0x550 <KEYPAD_readCols>
		
		switch(loc_u8_colSelect)
     61e:	89 81       	ldd	r24, Y+1	; 0x01
     620:	8b 30       	cpi	r24, 0x0B	; 11
     622:	89 f0       	breq	.+34     	; 0x646 <KEYPAD_GetKey+0x5e>
     624:	18 f4       	brcc	.+6      	; 0x62c <KEYPAD_GetKey+0x44>
     626:	87 30       	cpi	r24, 0x07	; 7
     628:	99 f0       	breq	.+38     	; 0x650 <KEYPAD_GetKey+0x68>
     62a:	16 c0       	rjmp	.+44     	; 0x658 <KEYPAD_GetKey+0x70>
     62c:	8d 30       	cpi	r24, 0x0D	; 13
     62e:	31 f0       	breq	.+12     	; 0x63c <KEYPAD_GetKey+0x54>
     630:	8e 30       	cpi	r24, 0x0E	; 14
     632:	91 f4       	brne	.+36     	; 0x658 <KEYPAD_GetKey+0x70>
		{
			case COL_0_PATTERN : loc_enu_returnKey = (loc_u8_itrator*4);break;
     634:	01 2f       	mov	r16, r17
     636:	00 0f       	add	r16, r16
     638:	00 0f       	add	r16, r16
     63a:	0e c0       	rjmp	.+28     	; 0x658 <KEYPAD_GetKey+0x70>
			case COL_1_PATTERN : loc_enu_returnKey = (loc_u8_itrator*4)+1;break;
     63c:	01 2f       	mov	r16, r17
     63e:	00 0f       	add	r16, r16
     640:	00 0f       	add	r16, r16
     642:	0f 5f       	subi	r16, 0xFF	; 255
     644:	09 c0       	rjmp	.+18     	; 0x658 <KEYPAD_GetKey+0x70>
			case COL_2_PATTERN : loc_enu_returnKey = (loc_u8_itrator*4)+2;break;
     646:	01 2f       	mov	r16, r17
     648:	00 0f       	add	r16, r16
     64a:	00 0f       	add	r16, r16
     64c:	0e 5f       	subi	r16, 0xFE	; 254
     64e:	04 c0       	rjmp	.+8      	; 0x658 <KEYPAD_GetKey+0x70>
			case COL_3_PATTERN : loc_enu_returnKey = (loc_u8_itrator*4)+3;break;
     650:	01 2f       	mov	r16, r17
     652:	00 0f       	add	r16, r16
     654:	00 0f       	add	r16, r16
     656:	0d 5f       	subi	r16, 0xFD	; 253
			default:break;
		}
		if(loc_enu_returnKey == KEY_NOTHING)
     658:	00 31       	cpi	r16, 0x10	; 16
     65a:	41 f4       	brne	.+16     	; 0x66c <KEYPAD_GetKey+0x84>
{
	KEYPAD_enu_PressedKey_t loc_enu_returnKey = KEY_NOTHING;
	u8                      loc_u8_itrator    = FALSE;
	u8                      loc_u8_colSelect  = FALSE;
	
	for(;loc_u8_itrator<ROWS_NUMBER;loc_u8_itrator++)
     65c:	1f 5f       	subi	r17, 0xFF	; 255
     65e:	14 30       	cpi	r17, 0x04	; 4
     660:	70 f2       	brcs	.-100    	; 0x5fe <KEYPAD_GetKey+0x16>
     662:	04 c0       	rjmp	.+8      	; 0x66c <KEYPAD_GetKey+0x84>
		
	}
	
	while(loc_u8_colSelect != 0x0F)
	{
		KEYPAD_readCols(&loc_u8_colSelect);
     664:	ce 01       	movw	r24, r28
     666:	01 96       	adiw	r24, 0x01	; 1
     668:	0e 94 a8 02 	call	0x550	; 0x550 <KEYPAD_readCols>
		
		
		
	}
	
	while(loc_u8_colSelect != 0x0F)
     66c:	89 81       	ldd	r24, Y+1	; 0x01
     66e:	8f 30       	cpi	r24, 0x0F	; 15
     670:	c9 f7       	brne	.-14     	; 0x664 <KEYPAD_GetKey+0x7c>
	{
		KEYPAD_readCols(&loc_u8_colSelect);
	};
	return loc_enu_returnKey;
}
     672:	80 2f       	mov	r24, r16
     674:	0f 90       	pop	r0
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	1f 91       	pop	r17
     67c:	0f 91       	pop	r16
     67e:	08 95       	ret

00000680 <LCD_send>:
	else if (arg_u8_row == 1)
	LCD_vidSendCommand(LCD_SET_DDRAM_ADDR_CMD + 0x40 + arg_u8_col);
	else if (arg_u8_row == 2)
	LCD_vidSendCommand(LCD_SET_DDRAM_ADDR_CMD + 0x14 + arg_u8_col);
	else if (arg_u8_row == 3)
	LCD_vidSendCommand(LCD_SET_DDRAM_ADDR_CMD + 0x54 + arg_u8_col);
     680:	cf 93       	push	r28
     682:	df 93       	push	r29
     684:	c8 2f       	mov	r28, r24
     686:	d6 2f       	mov	r29, r22
     688:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <loc_u8_Control.1861>
     68c:	81 11       	cpse	r24, r1
     68e:	2b c0       	rjmp	.+86     	; 0x6e6 <LCD_send+0x66>
     690:	61 e0       	ldi	r22, 0x01	; 1
     692:	82 e0       	ldi	r24, 0x02	; 2
     694:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
     698:	c1 11       	cpse	r28, r1
     69a:	05 c0       	rjmp	.+10     	; 0x6a6 <LCD_send+0x26>
     69c:	60 e0       	ldi	r22, 0x00	; 0
     69e:	83 e0       	ldi	r24, 0x03	; 3
     6a0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
     6a4:	06 c0       	rjmp	.+12     	; 0x6b2 <LCD_send+0x32>
     6a6:	c1 30       	cpi	r28, 0x01	; 1
     6a8:	21 f4       	brne	.+8      	; 0x6b2 <LCD_send+0x32>
     6aa:	61 e0       	ldi	r22, 0x01	; 1
     6ac:	83 e0       	ldi	r24, 0x03	; 3
     6ae:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
     6b2:	c0 e0       	ldi	r28, 0x00	; 0
     6b4:	11 c0       	rjmp	.+34     	; 0x6d8 <LCD_send+0x58>
     6b6:	ec 2f       	mov	r30, r28
     6b8:	f0 e0       	ldi	r31, 0x00	; 0
     6ba:	6d 2f       	mov	r22, r29
     6bc:	70 e0       	ldi	r23, 0x00	; 0
     6be:	0c 2e       	mov	r0, r28
     6c0:	02 c0       	rjmp	.+4      	; 0x6c6 <LCD_send+0x46>
     6c2:	75 95       	asr	r23
     6c4:	67 95       	ror	r22
     6c6:	0a 94       	dec	r0
     6c8:	e2 f7       	brpl	.-8      	; 0x6c2 <LCD_send+0x42>
     6ca:	61 70       	andi	r22, 0x01	; 1
     6cc:	e3 58       	subi	r30, 0x83	; 131
     6ce:	ff 4f       	sbci	r31, 0xFF	; 255
     6d0:	80 81       	ld	r24, Z
     6d2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
     6d6:	cf 5f       	subi	r28, 0xFF	; 255
     6d8:	c4 30       	cpi	r28, 0x04	; 4
     6da:	68 f3       	brcs	.-38     	; 0x6b6 <LCD_send+0x36>
     6dc:	60 e0       	ldi	r22, 0x00	; 0
     6de:	82 e0       	ldi	r24, 0x02	; 2
     6e0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
     6e4:	06 c0       	rjmp	.+12     	; 0x6f2 <LCD_send+0x72>
     6e6:	60 e0       	ldi	r22, 0x00	; 0
     6e8:	82 e0       	ldi	r24, 0x02	; 2
     6ea:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <DIO_enu_WriteChannel>
     6ee:	10 92 f6 00 	sts	0x00F6, r1	; 0x8000f6 <loc_u8_Control.1861>
     6f2:	80 e0       	ldi	r24, 0x00	; 0
     6f4:	df 91       	pop	r29
     6f6:	cf 91       	pop	r28
     6f8:	08 95       	ret

000006fa <LCD_enu_InitWithOs>:
     6fa:	80 91 f5 00 	lds	r24, 0x00F5	; 0x8000f5 <loc_u8_sendControl.1872>
     6fe:	81 11       	cpse	r24, r1
     700:	10 c0       	rjmp	.+32     	; 0x722 <LCD_enu_InitWithOs+0x28>
     702:	e0 91 f4 00 	lds	r30, 0x00F4	; 0x8000f4 <loc_u8_ApiControl.1871>
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	ef 57       	subi	r30, 0x7F	; 127
     70a:	ff 4f       	sbci	r31, 0xFF	; 255
     70c:	60 81       	ld	r22, Z
     70e:	62 95       	swap	r22
     710:	6f 70       	andi	r22, 0x0F	; 15
     712:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     716:	81 11       	cpse	r24, r1
     718:	17 c0       	rjmp	.+46     	; 0x748 <LCD_enu_InitWithOs+0x4e>
     71a:	91 e0       	ldi	r25, 0x01	; 1
     71c:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <loc_u8_sendControl.1872>
     720:	18 c0       	rjmp	.+48     	; 0x752 <LCD_enu_InitWithOs+0x58>
     722:	e0 91 f4 00 	lds	r30, 0x00F4	; 0x8000f4 <loc_u8_ApiControl.1871>
     726:	f0 e0       	ldi	r31, 0x00	; 0
     728:	ef 57       	subi	r30, 0x7F	; 127
     72a:	ff 4f       	sbci	r31, 0xFF	; 255
     72c:	60 81       	ld	r22, Z
     72e:	80 e0       	ldi	r24, 0x00	; 0
     730:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     734:	81 11       	cpse	r24, r1
     736:	0a c0       	rjmp	.+20     	; 0x74c <LCD_enu_InitWithOs+0x52>
     738:	10 92 f5 00 	sts	0x00F5, r1	; 0x8000f5 <loc_u8_sendControl.1872>
     73c:	90 91 f4 00 	lds	r25, 0x00F4	; 0x8000f4 <loc_u8_ApiControl.1871>
     740:	94 30       	cpi	r25, 0x04	; 4
     742:	31 f0       	breq	.+12     	; 0x750 <LCD_enu_InitWithOs+0x56>
     744:	91 e0       	ldi	r25, 0x01	; 1
     746:	05 c0       	rjmp	.+10     	; 0x752 <LCD_enu_InitWithOs+0x58>
     748:	91 e0       	ldi	r25, 0x01	; 1
     74a:	03 c0       	rjmp	.+6      	; 0x752 <LCD_enu_InitWithOs+0x58>
     74c:	91 e0       	ldi	r25, 0x01	; 1
     74e:	01 c0       	rjmp	.+2      	; 0x752 <LCD_enu_InitWithOs+0x58>
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	81 11       	cpse	r24, r1
     754:	09 c0       	rjmp	.+18     	; 0x768 <LCD_enu_InitWithOs+0x6e>
     756:	80 91 f5 00 	lds	r24, 0x00F5	; 0x8000f5 <loc_u8_sendControl.1872>
     75a:	81 11       	cpse	r24, r1
     75c:	05 c0       	rjmp	.+10     	; 0x768 <LCD_enu_InitWithOs+0x6e>
     75e:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <loc_u8_ApiControl.1871>
     762:	8f 5f       	subi	r24, 0xFF	; 255
     764:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <loc_u8_ApiControl.1871>
     768:	89 2f       	mov	r24, r25
     76a:	08 95       	ret

0000076c <LCD_writeString>:
     76c:	cf 93       	push	r28
     76e:	df 93       	push	r29
     770:	ec 01       	movw	r28, r24
     772:	80 91 f3 00 	lds	r24, 0x00F3	; 0x8000f3 <state.1878>
     776:	81 11       	cpse	r24, r1
     778:	11 c0       	rjmp	.+34     	; 0x79c <LCD_writeString+0x30>
     77a:	90 91 f2 00 	lds	r25, 0x00F2	; 0x8000f2 <sloc_u8_itartor.1877>
     77e:	fe 01       	movw	r30, r28
     780:	e9 0f       	add	r30, r25
     782:	f1 1d       	adc	r31, r1
     784:	60 81       	ld	r22, Z
     786:	66 23       	and	r22, r22
     788:	49 f0       	breq	.+18     	; 0x79c <LCD_writeString+0x30>
     78a:	62 95       	swap	r22
     78c:	6f 70       	andi	r22, 0x0F	; 15
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     794:	81 e0       	ldi	r24, 0x01	; 1
     796:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <state.1878>
     79a:	1e c0       	rjmp	.+60     	; 0x7d8 <LCD_writeString+0x6c>
     79c:	81 30       	cpi	r24, 0x01	; 1
     79e:	c9 f4       	brne	.+50     	; 0x7d2 <LCD_writeString+0x66>
     7a0:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <sloc_u8_itartor.1877>
     7a4:	91 e0       	ldi	r25, 0x01	; 1
     7a6:	98 0f       	add	r25, r24
     7a8:	90 93 f2 00 	sts	0x00F2, r25	; 0x8000f2 <sloc_u8_itartor.1877>
     7ac:	fe 01       	movw	r30, r28
     7ae:	e8 0f       	add	r30, r24
     7b0:	f1 1d       	adc	r31, r1
     7b2:	60 81       	ld	r22, Z
     7b4:	81 e0       	ldi	r24, 0x01	; 1
     7b6:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     7ba:	10 92 f3 00 	sts	0x00F3, r1	; 0x8000f3 <state.1878>
     7be:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <sloc_u8_itartor.1877>
     7c2:	c8 0f       	add	r28, r24
     7c4:	d1 1d       	adc	r29, r1
     7c6:	88 81       	ld	r24, Y
     7c8:	81 11       	cpse	r24, r1
     7ca:	05 c0       	rjmp	.+10     	; 0x7d6 <LCD_writeString+0x6a>
     7cc:	10 92 f2 00 	sts	0x00F2, r1	; 0x8000f2 <sloc_u8_itartor.1877>
     7d0:	03 c0       	rjmp	.+6      	; 0x7d8 <LCD_writeString+0x6c>
     7d2:	81 e0       	ldi	r24, 0x01	; 1
     7d4:	01 c0       	rjmp	.+2      	; 0x7d8 <LCD_writeString+0x6c>
     7d6:	81 e0       	ldi	r24, 0x01	; 1
     7d8:	df 91       	pop	r29
     7da:	cf 91       	pop	r28
     7dc:	08 95       	ret

000007de <LCD_writeNumber>:
     7de:	cf 92       	push	r12
     7e0:	df 92       	push	r13
     7e2:	ef 92       	push	r14
     7e4:	ff 92       	push	r15
     7e6:	0f 93       	push	r16
     7e8:	1f 93       	push	r17
     7ea:	61 15       	cp	r22, r1
     7ec:	71 05       	cpc	r23, r1
     7ee:	81 05       	cpc	r24, r1
     7f0:	91 05       	cpc	r25, r1
     7f2:	a1 f4       	brne	.+40     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
     7f4:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <state.1884>
     7f8:	81 11       	cpse	r24, r1
     7fa:	08 c0       	rjmp	.+16     	; 0x80c <__DATA_REGION_LENGTH__+0xc>
     7fc:	63 e0       	ldi	r22, 0x03	; 3
     7fe:	81 e0       	ldi	r24, 0x01	; 1
     800:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     804:	81 e0       	ldi	r24, 0x01	; 1
     806:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <state.1884>
     80a:	af c0       	rjmp	.+350    	; 0x96a <__stack+0x10b>
     80c:	60 e3       	ldi	r22, 0x30	; 48
     80e:	81 e0       	ldi	r24, 0x01	; 1
     810:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     814:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <state.1884>
     818:	80 e0       	ldi	r24, 0x00	; 0
     81a:	a7 c0       	rjmp	.+334    	; 0x96a <__stack+0x10b>
     81c:	20 91 f1 00 	lds	r18, 0x00F1	; 0x8000f1 <state.1884>
     820:	22 23       	and	r18, r18
     822:	89 f1       	breq	.+98     	; 0x886 <__stack+0x27>
     824:	39 c0       	rjmp	.+114    	; 0x898 <__stack+0x39>
     826:	c0 90 79 00 	lds	r12, 0x0079	; 0x800079 <loc_u8_inverse.1885>
     82a:	d0 90 7a 00 	lds	r13, 0x007A	; 0x80007a <loc_u8_inverse.1885+0x1>
     82e:	e0 90 7b 00 	lds	r14, 0x007B	; 0x80007b <loc_u8_inverse.1885+0x2>
     832:	f0 90 7c 00 	lds	r15, 0x007C	; 0x80007c <loc_u8_inverse.1885+0x3>
     836:	cc 0c       	add	r12, r12
     838:	dd 1c       	adc	r13, r13
     83a:	ee 1c       	adc	r14, r14
     83c:	ff 1c       	adc	r15, r15
     83e:	97 01       	movw	r18, r14
     840:	86 01       	movw	r16, r12
     842:	00 0f       	add	r16, r16
     844:	11 1f       	adc	r17, r17
     846:	22 1f       	adc	r18, r18
     848:	33 1f       	adc	r19, r19
     84a:	00 0f       	add	r16, r16
     84c:	11 1f       	adc	r17, r17
     84e:	22 1f       	adc	r18, r18
     850:	33 1f       	adc	r19, r19
     852:	c0 0e       	add	r12, r16
     854:	d1 1e       	adc	r13, r17
     856:	e2 1e       	adc	r14, r18
     858:	f3 1e       	adc	r15, r19
     85a:	2a e0       	ldi	r18, 0x0A	; 10
     85c:	30 e0       	ldi	r19, 0x00	; 0
     85e:	40 e0       	ldi	r20, 0x00	; 0
     860:	50 e0       	ldi	r21, 0x00	; 0
     862:	0e 94 a0 10 	call	0x2140	; 0x2140 <__divmodsi4>
     866:	c6 0e       	add	r12, r22
     868:	d7 1e       	adc	r13, r23
     86a:	e8 1e       	adc	r14, r24
     86c:	f9 1e       	adc	r15, r25
     86e:	c0 92 79 00 	sts	0x0079, r12	; 0x800079 <loc_u8_inverse.1885>
     872:	d0 92 7a 00 	sts	0x007A, r13	; 0x80007a <loc_u8_inverse.1885+0x1>
     876:	e0 92 7b 00 	sts	0x007B, r14	; 0x80007b <loc_u8_inverse.1885+0x2>
     87a:	f0 92 7c 00 	sts	0x007C, r15	; 0x80007c <loc_u8_inverse.1885+0x3>
     87e:	62 2f       	mov	r22, r18
     880:	73 2f       	mov	r23, r19
     882:	84 2f       	mov	r24, r20
     884:	95 2f       	mov	r25, r21
     886:	61 15       	cp	r22, r1
     888:	71 05       	cpc	r23, r1
     88a:	81 05       	cpc	r24, r1
     88c:	91 05       	cpc	r25, r1
     88e:	59 f6       	brne	.-106    	; 0x826 <__DATA_REGION_LENGTH__+0x26>
     890:	81 e0       	ldi	r24, 0x01	; 1
     892:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <state.1884>
     896:	69 c0       	rjmp	.+210    	; 0x96a <__stack+0x10b>
     898:	60 91 79 00 	lds	r22, 0x0079	; 0x800079 <loc_u8_inverse.1885>
     89c:	70 91 7a 00 	lds	r23, 0x007A	; 0x80007a <loc_u8_inverse.1885+0x1>
     8a0:	80 91 7b 00 	lds	r24, 0x007B	; 0x80007b <loc_u8_inverse.1885+0x2>
     8a4:	90 91 7c 00 	lds	r25, 0x007C	; 0x80007c <loc_u8_inverse.1885+0x3>
     8a8:	61 30       	cpi	r22, 0x01	; 1
     8aa:	71 05       	cpc	r23, r1
     8ac:	81 05       	cpc	r24, r1
     8ae:	91 05       	cpc	r25, r1
     8b0:	01 f1       	breq	.+64     	; 0x8f2 <__stack+0x93>
     8b2:	20 91 f0 00 	lds	r18, 0x00F0	; 0x8000f0 <sloc_u8_itartor.1883>
     8b6:	21 11       	cpse	r18, r1
     8b8:	1c c0       	rjmp	.+56     	; 0x8f2 <__stack+0x93>
     8ba:	2a e0       	ldi	r18, 0x0A	; 10
     8bc:	30 e0       	ldi	r19, 0x00	; 0
     8be:	40 e0       	ldi	r20, 0x00	; 0
     8c0:	50 e0       	ldi	r21, 0x00	; 0
     8c2:	0e 94 7e 10 	call	0x20fc	; 0x20fc <__udivmodsi4>
     8c6:	dc 01       	movw	r26, r24
     8c8:	cb 01       	movw	r24, r22
     8ca:	c0 96       	adiw	r24, 0x30	; 48
     8cc:	a1 1d       	adc	r26, r1
     8ce:	b1 1d       	adc	r27, r1
     8d0:	bc 01       	movw	r22, r24
     8d2:	cd 01       	movw	r24, r26
     8d4:	68 94       	set
     8d6:	13 f8       	bld	r1, 3
     8d8:	96 95       	lsr	r25
     8da:	87 95       	ror	r24
     8dc:	77 95       	ror	r23
     8de:	67 95       	ror	r22
     8e0:	16 94       	lsr	r1
     8e2:	d1 f7       	brne	.-12     	; 0x8d8 <__stack+0x79>
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     8ea:	81 e0       	ldi	r24, 0x01	; 1
     8ec:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <sloc_u8_itartor.1883>
     8f0:	3c c0       	rjmp	.+120    	; 0x96a <__stack+0x10b>
     8f2:	61 30       	cpi	r22, 0x01	; 1
     8f4:	71 05       	cpc	r23, r1
     8f6:	81 05       	cpc	r24, r1
     8f8:	91 05       	cpc	r25, r1
     8fa:	59 f1       	breq	.+86     	; 0x952 <__stack+0xf3>
     8fc:	20 91 f0 00 	lds	r18, 0x00F0	; 0x8000f0 <sloc_u8_itartor.1883>
     900:	21 30       	cpi	r18, 0x01	; 1
     902:	39 f5       	brne	.+78     	; 0x952 <__stack+0xf3>
     904:	0f 2e       	mov	r0, r31
     906:	fa e0       	ldi	r31, 0x0A	; 10
     908:	cf 2e       	mov	r12, r31
     90a:	d1 2c       	mov	r13, r1
     90c:	e1 2c       	mov	r14, r1
     90e:	f1 2c       	mov	r15, r1
     910:	f0 2d       	mov	r31, r0
     912:	a7 01       	movw	r20, r14
     914:	96 01       	movw	r18, r12
     916:	0e 94 7e 10 	call	0x20fc	; 0x20fc <__udivmodsi4>
     91a:	60 5d       	subi	r22, 0xD0	; 208
     91c:	81 e0       	ldi	r24, 0x01	; 1
     91e:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     922:	60 91 79 00 	lds	r22, 0x0079	; 0x800079 <loc_u8_inverse.1885>
     926:	70 91 7a 00 	lds	r23, 0x007A	; 0x80007a <loc_u8_inverse.1885+0x1>
     92a:	80 91 7b 00 	lds	r24, 0x007B	; 0x80007b <loc_u8_inverse.1885+0x2>
     92e:	90 91 7c 00 	lds	r25, 0x007C	; 0x80007c <loc_u8_inverse.1885+0x3>
     932:	a7 01       	movw	r20, r14
     934:	96 01       	movw	r18, r12
     936:	0e 94 7e 10 	call	0x20fc	; 0x20fc <__udivmodsi4>
     93a:	20 93 79 00 	sts	0x0079, r18	; 0x800079 <loc_u8_inverse.1885>
     93e:	30 93 7a 00 	sts	0x007A, r19	; 0x80007a <loc_u8_inverse.1885+0x1>
     942:	40 93 7b 00 	sts	0x007B, r20	; 0x80007b <loc_u8_inverse.1885+0x2>
     946:	50 93 7c 00 	sts	0x007C, r21	; 0x80007c <loc_u8_inverse.1885+0x3>
     94a:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <sloc_u8_itartor.1883>
     94e:	81 e0       	ldi	r24, 0x01	; 1
     950:	0c c0       	rjmp	.+24     	; 0x96a <__stack+0x10b>
     952:	61 30       	cpi	r22, 0x01	; 1
     954:	71 05       	cpc	r23, r1
     956:	81 05       	cpc	r24, r1
     958:	91 05       	cpc	r25, r1
     95a:	31 f4       	brne	.+12     	; 0x968 <__stack+0x109>
     95c:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <state.1884>
     960:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <sloc_u8_itartor.1883>
     964:	80 e0       	ldi	r24, 0x00	; 0
     966:	01 c0       	rjmp	.+2      	; 0x96a <__stack+0x10b>
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	1f 91       	pop	r17
     96c:	0f 91       	pop	r16
     96e:	ff 90       	pop	r15
     970:	ef 90       	pop	r14
     972:	df 90       	pop	r13
     974:	cf 90       	pop	r12
     976:	08 95       	ret

00000978 <LCD_CreateCustomCharacter>:
     978:	68 30       	cpi	r22, 0x08	; 8
     97a:	08 f0       	brcs	.+2      	; 0x97e <LCD_CreateCustomCharacter+0x6>
     97c:	5d c0       	rjmp	.+186    	; 0xa38 <LCD_CreateCustomCharacter+0xc0>
     97e:	20 91 ef 00 	lds	r18, 0x00EF	; 0x8000ef <sloc_u8_createState.1894>
     982:	21 11       	cpse	r18, r1
     984:	0c c0       	rjmp	.+24     	; 0x99e <LCD_CreateCustomCharacter+0x26>
     986:	70 e0       	ldi	r23, 0x00	; 0
     988:	68 5f       	subi	r22, 0xF8	; 248
     98a:	7f 4f       	sbci	r23, 0xFF	; 255
     98c:	75 95       	asr	r23
     98e:	67 95       	ror	r22
     990:	80 e0       	ldi	r24, 0x00	; 0
     992:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     996:	81 e0       	ldi	r24, 0x01	; 1
     998:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <sloc_u8_createState.1894>
     99c:	32 c0       	rjmp	.+100    	; 0xa02 <LCD_CreateCustomCharacter+0x8a>
     99e:	21 30       	cpi	r18, 0x01	; 1
     9a0:	69 f4       	brne	.+26     	; 0x9bc <LCD_CreateCustomCharacter+0x44>
     9a2:	70 e0       	ldi	r23, 0x00	; 0
     9a4:	68 5f       	subi	r22, 0xF8	; 248
     9a6:	7f 4f       	sbci	r23, 0xFF	; 255
     9a8:	66 0f       	add	r22, r22
     9aa:	66 0f       	add	r22, r22
     9ac:	66 0f       	add	r22, r22
     9ae:	80 e0       	ldi	r24, 0x00	; 0
     9b0:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     9b4:	82 e0       	ldi	r24, 0x02	; 2
     9b6:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <sloc_u8_createState.1894>
     9ba:	23 c0       	rjmp	.+70     	; 0xa02 <LCD_CreateCustomCharacter+0x8a>
     9bc:	22 30       	cpi	r18, 0x02	; 2
     9be:	79 f4       	brne	.+30     	; 0x9de <LCD_CreateCustomCharacter+0x66>
     9c0:	20 91 ee 00 	lds	r18, 0x00EE	; 0x8000ee <sloc_u8_itrator.1895>
     9c4:	fc 01       	movw	r30, r24
     9c6:	e2 0f       	add	r30, r18
     9c8:	f1 1d       	adc	r31, r1
     9ca:	60 81       	ld	r22, Z
     9cc:	62 95       	swap	r22
     9ce:	6f 70       	andi	r22, 0x0F	; 15
     9d0:	81 e0       	ldi	r24, 0x01	; 1
     9d2:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     9d6:	83 e0       	ldi	r24, 0x03	; 3
     9d8:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <sloc_u8_createState.1894>
     9dc:	12 c0       	rjmp	.+36     	; 0xa02 <LCD_CreateCustomCharacter+0x8a>
     9de:	23 30       	cpi	r18, 0x03	; 3
     9e0:	81 f4       	brne	.+32     	; 0xa02 <LCD_CreateCustomCharacter+0x8a>
     9e2:	20 91 ee 00 	lds	r18, 0x00EE	; 0x8000ee <sloc_u8_itrator.1895>
     9e6:	31 e0       	ldi	r19, 0x01	; 1
     9e8:	32 0f       	add	r19, r18
     9ea:	30 93 ee 00 	sts	0x00EE, r19	; 0x8000ee <sloc_u8_itrator.1895>
     9ee:	fc 01       	movw	r30, r24
     9f0:	e2 0f       	add	r30, r18
     9f2:	f1 1d       	adc	r31, r1
     9f4:	60 81       	ld	r22, Z
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     9fc:	82 e0       	ldi	r24, 0x02	; 2
     9fe:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <sloc_u8_createState.1894>
     a02:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <sloc_u8_itrator.1895>
     a06:	88 30       	cpi	r24, 0x08	; 8
     a08:	59 f4       	brne	.+22     	; 0xa20 <LCD_CreateCustomCharacter+0xa8>
     a0a:	68 e0       	ldi	r22, 0x08	; 8
     a0c:	80 e0       	ldi	r24, 0x00	; 0
     a0e:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     a12:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <sloc_u8_itrator.1895>
     a16:	84 e0       	ldi	r24, 0x04	; 4
     a18:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <sloc_u8_createState.1894>
     a1c:	81 e0       	ldi	r24, 0x01	; 1
     a1e:	08 95       	ret
     a20:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <sloc_u8_createState.1894>
     a24:	84 30       	cpi	r24, 0x04	; 4
     a26:	51 f4       	brne	.+20     	; 0xa3c <LCD_CreateCustomCharacter+0xc4>
     a28:	60 e8       	ldi	r22, 0x80	; 128
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     a30:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <sloc_u8_createState.1894>
     a34:	80 e0       	ldi	r24, 0x00	; 0
     a36:	08 95       	ret
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	08 95       	ret
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	08 95       	ret

00000a40 <LCD_GoToXY>:

LCD_API_STATE_t LCD_GoToXY(u8 arg_u8_row,u8 arg_u8_col)
{
	LCD_API_STATE_t loc_return = LCD_API_WAITING;
	static u8 loc_u8_nibble = FALSE;
	if (loc_u8_nibble == FALSE)
     a40:	90 91 ed 00 	lds	r25, 0x00ED	; 0x8000ed <loc_u8_nibble.1938>
     a44:	91 11       	cpse	r25, r1
     a46:	46 c0       	rjmp	.+140    	; 0xad4 <LCD_GoToXY+0x94>
	{
		if(arg_u8_row == 0)
     a48:	81 11       	cpse	r24, r1
     a4a:	0e c0       	rjmp	.+28     	; 0xa68 <LCD_GoToXY+0x28>
		LCD_send(LCD_CMD,(LCD_SET_DDRAM_ADDR_CMD + 0 + arg_u8_col)>>4);
     a4c:	70 e0       	ldi	r23, 0x00	; 0
     a4e:	60 58       	subi	r22, 0x80	; 128
     a50:	7f 4f       	sbci	r23, 0xFF	; 255
     a52:	75 95       	asr	r23
     a54:	67 95       	ror	r22
     a56:	75 95       	asr	r23
     a58:	67 95       	ror	r22
     a5a:	75 95       	asr	r23
     a5c:	67 95       	ror	r22
     a5e:	75 95       	asr	r23
     a60:	67 95       	ror	r22
     a62:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     a66:	32 c0       	rjmp	.+100    	; 0xacc <LCD_GoToXY+0x8c>
		else if (arg_u8_row == 1)
     a68:	81 30       	cpi	r24, 0x01	; 1
     a6a:	79 f4       	brne	.+30     	; 0xa8a <LCD_GoToXY+0x4a>
		LCD_send(LCD_CMD,(LCD_SET_DDRAM_ADDR_CMD + 0x40 + arg_u8_col)>>4);
     a6c:	70 e0       	ldi	r23, 0x00	; 0
     a6e:	60 54       	subi	r22, 0x40	; 64
     a70:	7f 4f       	sbci	r23, 0xFF	; 255
     a72:	75 95       	asr	r23
     a74:	67 95       	ror	r22
     a76:	75 95       	asr	r23
     a78:	67 95       	ror	r22
     a7a:	75 95       	asr	r23
     a7c:	67 95       	ror	r22
     a7e:	75 95       	asr	r23
     a80:	67 95       	ror	r22
     a82:	80 e0       	ldi	r24, 0x00	; 0
     a84:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     a88:	21 c0       	rjmp	.+66     	; 0xacc <LCD_GoToXY+0x8c>
		else if (arg_u8_row == 2)
     a8a:	82 30       	cpi	r24, 0x02	; 2
     a8c:	79 f4       	brne	.+30     	; 0xaac <LCD_GoToXY+0x6c>
		LCD_send(LCD_CMD,(LCD_SET_DDRAM_ADDR_CMD + 0x14 + arg_u8_col)>>4);
     a8e:	70 e0       	ldi	r23, 0x00	; 0
     a90:	6c 56       	subi	r22, 0x6C	; 108
     a92:	7f 4f       	sbci	r23, 0xFF	; 255
     a94:	75 95       	asr	r23
     a96:	67 95       	ror	r22
     a98:	75 95       	asr	r23
     a9a:	67 95       	ror	r22
     a9c:	75 95       	asr	r23
     a9e:	67 95       	ror	r22
     aa0:	75 95       	asr	r23
     aa2:	67 95       	ror	r22
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     aaa:	10 c0       	rjmp	.+32     	; 0xacc <LCD_GoToXY+0x8c>
		else if (arg_u8_row == 3)
     aac:	83 30       	cpi	r24, 0x03	; 3
     aae:	71 f4       	brne	.+28     	; 0xacc <LCD_GoToXY+0x8c>
		LCD_send(LCD_CMD,(LCD_SET_DDRAM_ADDR_CMD + 0x54 + arg_u8_col)>>4);
     ab0:	70 e0       	ldi	r23, 0x00	; 0
     ab2:	6c 52       	subi	r22, 0x2C	; 44
     ab4:	7f 4f       	sbci	r23, 0xFF	; 255
     ab6:	75 95       	asr	r23
     ab8:	67 95       	ror	r22
     aba:	75 95       	asr	r23
     abc:	67 95       	ror	r22
     abe:	75 95       	asr	r23
     ac0:	67 95       	ror	r22
     ac2:	75 95       	asr	r23
     ac4:	67 95       	ror	r22
     ac6:	80 e0       	ldi	r24, 0x00	; 0
     ac8:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
		
		loc_u8_nibble = TRUE;
     acc:	81 e0       	ldi	r24, 0x01	; 1
     ace:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <loc_u8_nibble.1938>
     ad2:	08 95       	ret
	}
	else
	{
		
			if(arg_u8_row == 0)
     ad4:	81 11       	cpse	r24, r1
     ad6:	04 c0       	rjmp	.+8      	; 0xae0 <LCD_GoToXY+0xa0>
			LCD_send(LCD_CMD,(LCD_SET_DDRAM_ADDR_CMD + 0 + arg_u8_col));
     ad8:	60 58       	subi	r22, 0x80	; 128
     ada:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     ade:	14 c0       	rjmp	.+40     	; 0xb08 <LCD_GoToXY+0xc8>
			else if (arg_u8_row == 1)
     ae0:	81 30       	cpi	r24, 0x01	; 1
     ae2:	29 f4       	brne	.+10     	; 0xaee <LCD_GoToXY+0xae>
			LCD_send(LCD_CMD,(LCD_SET_DDRAM_ADDR_CMD + 0x40 + arg_u8_col));
     ae4:	60 54       	subi	r22, 0x40	; 64
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     aec:	0d c0       	rjmp	.+26     	; 0xb08 <LCD_GoToXY+0xc8>
			else if (arg_u8_row == 2)
     aee:	82 30       	cpi	r24, 0x02	; 2
     af0:	29 f4       	brne	.+10     	; 0xafc <LCD_GoToXY+0xbc>
			LCD_send(LCD_CMD,(LCD_SET_DDRAM_ADDR_CMD + 0x14 + arg_u8_col));
     af2:	6c 56       	subi	r22, 0x6C	; 108
     af4:	80 e0       	ldi	r24, 0x00	; 0
     af6:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
     afa:	06 c0       	rjmp	.+12     	; 0xb08 <LCD_GoToXY+0xc8>
			else if (arg_u8_row == 3)
     afc:	83 30       	cpi	r24, 0x03	; 3
     afe:	21 f4       	brne	.+8      	; 0xb08 <LCD_GoToXY+0xc8>
			LCD_send(LCD_CMD,(LCD_SET_DDRAM_ADDR_CMD + 0x54 + arg_u8_col));
     b00:	6c 52       	subi	r22, 0x2C	; 44
     b02:	80 e0       	ldi	r24, 0x00	; 0
     b04:	0e 94 40 03 	call	0x680	; 0x680 <LCD_send>
			
			loc_u8_nibble = FALSE;
     b08:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <loc_u8_nibble.1938>
			loc_return = LCD_API_JOB_DONE;
     b0c:	80 e0       	ldi	r24, 0x00	; 0
		
	}
	return loc_return;
}
     b0e:	08 95       	ret

00000b10 <ADC_voidInit>:
	return loc_enum_returnStatus;
}
void ADC_voidDisable(void)
{
	ADMUX  = FALSE;
	ADCSRA = FALSE;
     b10:	87 b1       	in	r24, 0x07	; 7
     b12:	80 64       	ori	r24, 0x40	; 64
     b14:	87 b9       	out	0x07, r24	; 7
     b16:	87 b1       	in	r24, 0x07	; 7
     b18:	8f 77       	andi	r24, 0x7F	; 127
     b1a:	87 b9       	out	0x07, r24	; 7
     b1c:	87 b1       	in	r24, 0x07	; 7
     b1e:	8f 7d       	andi	r24, 0xDF	; 223
     b20:	87 b9       	out	0x07, r24	; 7
     b22:	86 b1       	in	r24, 0x06	; 6
     b24:	8e 7f       	andi	r24, 0xFE	; 254
     b26:	86 b9       	out	0x06, r24	; 6
     b28:	86 b1       	in	r24, 0x06	; 6
     b2a:	8d 7f       	andi	r24, 0xFD	; 253
     b2c:	86 b9       	out	0x06, r24	; 6
     b2e:	86 b1       	in	r24, 0x06	; 6
     b30:	8b 7f       	andi	r24, 0xFB	; 251
     b32:	86 b9       	out	0x06, r24	; 6
     b34:	86 b1       	in	r24, 0x06	; 6
     b36:	88 60       	ori	r24, 0x08	; 8
     b38:	86 b9       	out	0x06, r24	; 6
     b3a:	86 b1       	in	r24, 0x06	; 6
     b3c:	80 68       	ori	r24, 0x80	; 128
     b3e:	86 b9       	out	0x06, r24	; 6
     b40:	08 95       	ret

00000b42 <ADC_enum_setCallBack>:
     b42:	00 97       	sbiw	r24, 0x00	; 0
     b44:	31 f0       	breq	.+12     	; 0xb52 <ADC_enum_setCallBack+0x10>
     b46:	90 93 f8 00 	sts	0x00F8, r25	; 0x8000f8 <gl_ptr_ADC+0x1>
     b4a:	80 93 f7 00 	sts	0x00F7, r24	; 0x8000f7 <gl_ptr_ADC>
     b4e:	80 e0       	ldi	r24, 0x00	; 0
     b50:	08 95       	ret
     b52:	82 e0       	ldi	r24, 0x02	; 2
     b54:	08 95       	ret

00000b56 <ADC_enum_readValueInterrupt>:
     b56:	88 30       	cpi	r24, 0x08	; 8
     b58:	70 f4       	brcc	.+28     	; 0xb76 <ADC_enum_readValueInterrupt+0x20>
     b5a:	33 99       	sbic	0x06, 3	; 6
     b5c:	03 c0       	rjmp	.+6      	; 0xb64 <ADC_enum_readValueInterrupt+0xe>
     b5e:	96 b1       	in	r25, 0x06	; 6
     b60:	98 60       	ori	r25, 0x08	; 8
     b62:	96 b9       	out	0x06, r25	; 6
     b64:	97 b1       	in	r25, 0x07	; 7
     b66:	8f 71       	andi	r24, 0x1F	; 31
     b68:	89 2b       	or	r24, r25
     b6a:	87 b9       	out	0x07, r24	; 7
     b6c:	86 b1       	in	r24, 0x06	; 6
     b6e:	80 64       	ori	r24, 0x40	; 64
     b70:	86 b9       	out	0x06, r24	; 6
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	08 95       	ret
     b76:	81 e0       	ldi	r24, 0x01	; 1
     b78:	08 95       	ret

00000b7a <__vector_16>:




ISR(ADC_INT)
{
     b7a:	1f 92       	push	r1
     b7c:	0f 92       	push	r0
     b7e:	0f b6       	in	r0, 0x3f	; 63
     b80:	0f 92       	push	r0
     b82:	11 24       	eor	r1, r1
     b84:	2f 93       	push	r18
     b86:	3f 93       	push	r19
     b88:	4f 93       	push	r20
     b8a:	5f 93       	push	r21
     b8c:	6f 93       	push	r22
     b8e:	7f 93       	push	r23
     b90:	8f 93       	push	r24
     b92:	9f 93       	push	r25
     b94:	af 93       	push	r26
     b96:	bf 93       	push	r27
     b98:	ef 93       	push	r30
     b9a:	ff 93       	push	r31
	if(gl_ptr_ADC != PTR_NULL)
     b9c:	e0 91 f7 00 	lds	r30, 0x00F7	; 0x8000f7 <gl_ptr_ADC>
     ba0:	f0 91 f8 00 	lds	r31, 0x00F8	; 0x8000f8 <gl_ptr_ADC+0x1>
     ba4:	30 97       	sbiw	r30, 0x00	; 0
     ba6:	61 f0       	breq	.+24     	; 0xbc0 <__vector_16+0x46>
	{
		gl_u16_ConversionResult = (ADCLH & MASK_DATA); // MASK
     ba8:	84 b1       	in	r24, 0x04	; 4
     baa:	95 b1       	in	r25, 0x05	; 5
     bac:	9f 70       	andi	r25, 0x0F	; 15
     bae:	90 93 fa 00 	sts	0x00FA, r25	; 0x8000fa <gl_u16_ConversionResult+0x1>
     bb2:	80 93 f9 00 	sts	0x00F9, r24	; 0x8000f9 <gl_u16_ConversionResult>
		gl_ptr_ADC(gl_u16_ConversionResult);
     bb6:	80 91 f9 00 	lds	r24, 0x00F9	; 0x8000f9 <gl_u16_ConversionResult>
     bba:	90 91 fa 00 	lds	r25, 0x00FA	; 0x8000fa <gl_u16_ConversionResult+0x1>
     bbe:	09 95       	icall
	}
}
     bc0:	ff 91       	pop	r31
     bc2:	ef 91       	pop	r30
     bc4:	bf 91       	pop	r27
     bc6:	af 91       	pop	r26
     bc8:	9f 91       	pop	r25
     bca:	8f 91       	pop	r24
     bcc:	7f 91       	pop	r23
     bce:	6f 91       	pop	r22
     bd0:	5f 91       	pop	r21
     bd2:	4f 91       	pop	r20
     bd4:	3f 91       	pop	r19
     bd6:	2f 91       	pop	r18
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
     bdc:	0f 90       	pop	r0
     bde:	1f 90       	pop	r1
     be0:	18 95       	reti

00000be2 <DIO_enu_WriteChannel>:
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
	
	// calculate pin number and port number
	u8 loc_u8_pinNumber  = arg_enu_pinId % REG_SIZE ;
     be2:	28 2f       	mov	r18, r24
     be4:	27 70       	andi	r18, 0x07	; 7
	u8 loc_u8_portNumber = arg_enu_pinId / REG_SIZE ;
     be6:	98 2f       	mov	r25, r24
     be8:	96 95       	lsr	r25
     bea:	96 95       	lsr	r25
     bec:	96 95       	lsr	r25
	
	// case wrong pin
	if( arg_enu_pinId >= DIO_PINID_ERROR)
     bee:	80 32       	cpi	r24, 0x20	; 32
     bf0:	08 f0       	brcs	.+2      	; 0xbf4 <DIO_enu_WriteChannel+0x12>
     bf2:	78 c0       	rjmp	.+240    	; 0xce4 <DIO_enu_WriteChannel+0x102>
	{
		loc_enu_return_status = STATUS_DIO_PIN_NUMBER_ERROR;
	}
	// case wrong level
	else if( arg_enu_pinLevel >= DIO_PIN_LEVEL_ERROR)
     bf4:	62 30       	cpi	r22, 0x02	; 2
     bf6:	08 f0       	brcs	.+2      	; 0xbfa <DIO_enu_WriteChannel+0x18>
     bf8:	77 c0       	rjmp	.+238    	; 0xce8 <DIO_enu_WriteChannel+0x106>
		loc_enu_return_status = STATUS_DIO_PIN_LEVEL_CHOICE_ERROR;
	}
	else
	{
		// switch port number
		switch(loc_u8_portNumber)
     bfa:	91 30       	cpi	r25, 0x01	; 1
     bfc:	11 f1       	breq	.+68     	; 0xc42 <DIO_enu_WriteChannel+0x60>
     bfe:	30 f0       	brcs	.+12     	; 0xc0c <DIO_enu_WriteChannel+0x2a>
     c00:	92 30       	cpi	r25, 0x02	; 2
     c02:	d1 f1       	breq	.+116    	; 0xc78 <DIO_enu_WriteChannel+0x96>
     c04:	93 30       	cpi	r25, 0x03	; 3
     c06:	09 f4       	brne	.+2      	; 0xc0a <DIO_enu_WriteChannel+0x28>
     c08:	52 c0       	rjmp	.+164    	; 0xcae <DIO_enu_WriteChannel+0xcc>
     c0a:	70 c0       	rjmp	.+224    	; 0xcec <DIO_enu_WriteChannel+0x10a>
		{
			case DIO_PORT_NUMBER_A :
			{
				// if low level clear bit in PORT reg else set bit 
				(arg_enu_pinLevel == DIO_PIN_LEVEL_LOW)?CLR_BIT(DIO_PORTA,loc_u8_pinNumber):SET_BIT(DIO_PORTA,loc_u8_pinNumber);
     c0c:	61 11       	cpse	r22, r1
     c0e:	0d c0       	rjmp	.+26     	; 0xc2a <DIO_enu_WriteChannel+0x48>
     c10:	3b b3       	in	r19, 0x1b	; 27
     c12:	81 e0       	ldi	r24, 0x01	; 1
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	02 c0       	rjmp	.+4      	; 0xc1c <DIO_enu_WriteChannel+0x3a>
     c18:	88 0f       	add	r24, r24
     c1a:	99 1f       	adc	r25, r25
     c1c:	2a 95       	dec	r18
     c1e:	e2 f7       	brpl	.-8      	; 0xc18 <DIO_enu_WriteChannel+0x36>
     c20:	80 95       	com	r24
     c22:	83 23       	and	r24, r19
     c24:	8b bb       	out	0x1b, r24	; 27
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	08 95       	ret
		switch(loc_u8_portNumber)
		{
			case DIO_PORT_NUMBER_A :
			{
				// if low level clear bit in PORT reg else set bit 
				(arg_enu_pinLevel == DIO_PIN_LEVEL_LOW)?CLR_BIT(DIO_PORTA,loc_u8_pinNumber):SET_BIT(DIO_PORTA,loc_u8_pinNumber);
     c2a:	3b b3       	in	r19, 0x1b	; 27
     c2c:	81 e0       	ldi	r24, 0x01	; 1
     c2e:	90 e0       	ldi	r25, 0x00	; 0
     c30:	02 c0       	rjmp	.+4      	; 0xc36 <DIO_enu_WriteChannel+0x54>
     c32:	88 0f       	add	r24, r24
     c34:	99 1f       	adc	r25, r25
     c36:	2a 95       	dec	r18
     c38:	e2 f7       	brpl	.-8      	; 0xc32 <DIO_enu_WriteChannel+0x50>
     c3a:	83 2b       	or	r24, r19
     c3c:	8b bb       	out	0x1b, r24	; 27
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_B :
			{
				// if low level clear bit in PORT reg else set bit 
				(arg_enu_pinLevel == DIO_PIN_LEVEL_LOW)?CLR_BIT(DIO_PORTB,loc_u8_pinNumber):SET_BIT(DIO_PORTB,loc_u8_pinNumber);
     c42:	61 11       	cpse	r22, r1
     c44:	0d c0       	rjmp	.+26     	; 0xc60 <DIO_enu_WriteChannel+0x7e>
     c46:	38 b3       	in	r19, 0x18	; 24
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	02 c0       	rjmp	.+4      	; 0xc52 <DIO_enu_WriteChannel+0x70>
     c4e:	88 0f       	add	r24, r24
     c50:	99 1f       	adc	r25, r25
     c52:	2a 95       	dec	r18
     c54:	e2 f7       	brpl	.-8      	; 0xc4e <DIO_enu_WriteChannel+0x6c>
     c56:	80 95       	com	r24
     c58:	83 23       	and	r24, r19
     c5a:	88 bb       	out	0x18, r24	; 24
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_B :
			{
				// if low level clear bit in PORT reg else set bit 
				(arg_enu_pinLevel == DIO_PIN_LEVEL_LOW)?CLR_BIT(DIO_PORTB,loc_u8_pinNumber):SET_BIT(DIO_PORTB,loc_u8_pinNumber);
     c60:	38 b3       	in	r19, 0x18	; 24
     c62:	81 e0       	ldi	r24, 0x01	; 1
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	02 c0       	rjmp	.+4      	; 0xc6c <DIO_enu_WriteChannel+0x8a>
     c68:	88 0f       	add	r24, r24
     c6a:	99 1f       	adc	r25, r25
     c6c:	2a 95       	dec	r18
     c6e:	e2 f7       	brpl	.-8      	; 0xc68 <DIO_enu_WriteChannel+0x86>
     c70:	83 2b       	or	r24, r19
     c72:	88 bb       	out	0x18, r24	; 24
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     c74:	80 e0       	ldi	r24, 0x00	; 0
     c76:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_C :
			{
				// if low level clear bit in PORT reg else set bit 
				(arg_enu_pinLevel == DIO_PIN_LEVEL_LOW)?CLR_BIT(DIO_PORTC,loc_u8_pinNumber):SET_BIT(DIO_PORTC,loc_u8_pinNumber);
     c78:	61 11       	cpse	r22, r1
     c7a:	0d c0       	rjmp	.+26     	; 0xc96 <DIO_enu_WriteChannel+0xb4>
     c7c:	35 b3       	in	r19, 0x15	; 21
     c7e:	81 e0       	ldi	r24, 0x01	; 1
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	02 c0       	rjmp	.+4      	; 0xc88 <DIO_enu_WriteChannel+0xa6>
     c84:	88 0f       	add	r24, r24
     c86:	99 1f       	adc	r25, r25
     c88:	2a 95       	dec	r18
     c8a:	e2 f7       	brpl	.-8      	; 0xc84 <DIO_enu_WriteChannel+0xa2>
     c8c:	80 95       	com	r24
     c8e:	83 23       	and	r24, r19
     c90:	85 bb       	out	0x15, r24	; 21
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     c92:	80 e0       	ldi	r24, 0x00	; 0
     c94:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_C :
			{
				// if low level clear bit in PORT reg else set bit 
				(arg_enu_pinLevel == DIO_PIN_LEVEL_LOW)?CLR_BIT(DIO_PORTC,loc_u8_pinNumber):SET_BIT(DIO_PORTC,loc_u8_pinNumber);
     c96:	35 b3       	in	r19, 0x15	; 21
     c98:	81 e0       	ldi	r24, 0x01	; 1
     c9a:	90 e0       	ldi	r25, 0x00	; 0
     c9c:	02 c0       	rjmp	.+4      	; 0xca2 <DIO_enu_WriteChannel+0xc0>
     c9e:	88 0f       	add	r24, r24
     ca0:	99 1f       	adc	r25, r25
     ca2:	2a 95       	dec	r18
     ca4:	e2 f7       	brpl	.-8      	; 0xc9e <DIO_enu_WriteChannel+0xbc>
     ca6:	83 2b       	or	r24, r19
     ca8:	85 bb       	out	0x15, r24	; 21
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     caa:	80 e0       	ldi	r24, 0x00	; 0
     cac:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_D :
			{
				// if low level clear bit in PORT reg else set bit 
				(arg_enu_pinLevel == DIO_PIN_LEVEL_LOW)?CLR_BIT(DIO_PORTD,loc_u8_pinNumber):SET_BIT(DIO_PORTD,loc_u8_pinNumber);
     cae:	61 11       	cpse	r22, r1
     cb0:	0d c0       	rjmp	.+26     	; 0xccc <DIO_enu_WriteChannel+0xea>
     cb2:	32 b3       	in	r19, 0x12	; 18
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	02 c0       	rjmp	.+4      	; 0xcbe <DIO_enu_WriteChannel+0xdc>
     cba:	88 0f       	add	r24, r24
     cbc:	99 1f       	adc	r25, r25
     cbe:	2a 95       	dec	r18
     cc0:	e2 f7       	brpl	.-8      	; 0xcba <DIO_enu_WriteChannel+0xd8>
     cc2:	80 95       	com	r24
     cc4:	83 23       	and	r24, r19
     cc6:	82 bb       	out	0x12, r24	; 18
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     cc8:	80 e0       	ldi	r24, 0x00	; 0
     cca:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_D :
			{
				// if low level clear bit in PORT reg else set bit 
				(arg_enu_pinLevel == DIO_PIN_LEVEL_LOW)?CLR_BIT(DIO_PORTD,loc_u8_pinNumber):SET_BIT(DIO_PORTD,loc_u8_pinNumber);
     ccc:	32 b3       	in	r19, 0x12	; 18
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	90 e0       	ldi	r25, 0x00	; 0
     cd2:	02 c0       	rjmp	.+4      	; 0xcd8 <DIO_enu_WriteChannel+0xf6>
     cd4:	88 0f       	add	r24, r24
     cd6:	99 1f       	adc	r25, r25
     cd8:	2a 95       	dec	r18
     cda:	e2 f7       	brpl	.-8      	; 0xcd4 <DIO_enu_WriteChannel+0xf2>
     cdc:	83 2b       	or	r24, r19
     cde:	82 bb       	out	0x12, r24	; 18
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     ce0:	80 e0       	ldi	r24, 0x00	; 0
     ce2:	08 95       	ret
	u8 loc_u8_portNumber = arg_enu_pinId / REG_SIZE ;
	
	// case wrong pin
	if( arg_enu_pinId >= DIO_PINID_ERROR)
	{
		loc_enu_return_status = STATUS_DIO_PIN_NUMBER_ERROR;
     ce4:	81 e0       	ldi	r24, 0x01	; 1
     ce6:	08 95       	ret
	}
	// case wrong level
	else if( arg_enu_pinLevel >= DIO_PIN_LEVEL_ERROR)
	{
		loc_enu_return_status = STATUS_DIO_PIN_LEVEL_CHOICE_ERROR;
     ce8:	82 e0       	ldi	r24, 0x02	; 2
     cea:	08 95       	ret
*/
DIO_enu_return_status_t DIO_enu_WriteChannel(DIO_enu_PinId_t arg_enu_pinId,DIO_enu_PinLevel_t arg_enu_pinLevel)
{
	
	// loc return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     cec:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	
	
	return loc_enu_return_status;
}
     cee:	08 95       	ret

00000cf0 <DIO_enu_ReadChannel>:
{
	//loc for return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
	
	// calculate pin and port numbers
	u8 loc_u8_pinNumber  = arg_enu_pinId % REG_SIZE ;
     cf0:	28 2f       	mov	r18, r24
     cf2:	27 70       	andi	r18, 0x07	; 7
	u8 loc_u8_portNumber = arg_enu_pinId / REG_SIZE ;
     cf4:	98 2f       	mov	r25, r24
     cf6:	96 95       	lsr	r25
     cf8:	96 95       	lsr	r25
     cfa:	96 95       	lsr	r25
	
	// check if address is null
	if(ptr_value == PTR_NULL)
     cfc:	61 15       	cp	r22, r1
     cfe:	71 05       	cpc	r23, r1
     d00:	d1 f1       	breq	.+116    	; 0xd76 <DIO_enu_ReadChannel+0x86>
	{
		loc_enu_return_status = STATUS_DIO_NULL_PTR_ERROR;
	}
	// check on channel
	else if( arg_enu_pinId >= DIO_PINID_ERROR)
     d02:	80 32       	cpi	r24, 0x20	; 32
     d04:	d0 f5       	brcc	.+116    	; 0xd7a <DIO_enu_ReadChannel+0x8a>
	{
		loc_enu_return_status = STATUS_DIO_PIN_NUMBER_ERROR;
	}
	else
	{
		switch(loc_u8_portNumber)
     d06:	91 30       	cpi	r25, 0x01	; 1
     d08:	91 f0       	breq	.+36     	; 0xd2e <DIO_enu_ReadChannel+0x3e>
     d0a:	28 f0       	brcs	.+10     	; 0xd16 <DIO_enu_ReadChannel+0x26>
     d0c:	92 30       	cpi	r25, 0x02	; 2
     d0e:	d9 f0       	breq	.+54     	; 0xd46 <DIO_enu_ReadChannel+0x56>
     d10:	93 30       	cpi	r25, 0x03	; 3
     d12:	29 f1       	breq	.+74     	; 0xd5e <DIO_enu_ReadChannel+0x6e>
     d14:	34 c0       	rjmp	.+104    	; 0xd7e <DIO_enu_ReadChannel+0x8e>
		{
			case DIO_PORT_NUMBER_A :
			{
				// asign level 
				*ptr_value = GET_BIT(DIO_PINA,loc_u8_pinNumber);
     d16:	89 b3       	in	r24, 0x19	; 25
     d18:	90 e0       	ldi	r25, 0x00	; 0
     d1a:	02 c0       	rjmp	.+4      	; 0xd20 <DIO_enu_ReadChannel+0x30>
     d1c:	95 95       	asr	r25
     d1e:	87 95       	ror	r24
     d20:	2a 95       	dec	r18
     d22:	e2 f7       	brpl	.-8      	; 0xd1c <DIO_enu_ReadChannel+0x2c>
     d24:	81 70       	andi	r24, 0x01	; 1
     d26:	fb 01       	movw	r30, r22
     d28:	80 83       	st	Z, r24

*/
DIO_enu_return_status_t DIO_enu_ReadChannel(DIO_enu_PinId_t arg_enu_pinId,u8 *ptr_value)
{
	//loc for return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     d2a:	80 e0       	ldi	r24, 0x00	; 0
		{
			case DIO_PORT_NUMBER_A :
			{
				// asign level 
				*ptr_value = GET_BIT(DIO_PINA,loc_u8_pinNumber);
				break;
     d2c:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_B :
			{
				// asign level 
				*ptr_value = GET_BIT(DIO_PINB,loc_u8_pinNumber);
     d2e:	86 b3       	in	r24, 0x16	; 22
     d30:	90 e0       	ldi	r25, 0x00	; 0
     d32:	02 c0       	rjmp	.+4      	; 0xd38 <DIO_enu_ReadChannel+0x48>
     d34:	95 95       	asr	r25
     d36:	87 95       	ror	r24
     d38:	2a 95       	dec	r18
     d3a:	e2 f7       	brpl	.-8      	; 0xd34 <DIO_enu_ReadChannel+0x44>
     d3c:	81 70       	andi	r24, 0x01	; 1
     d3e:	fb 01       	movw	r30, r22
     d40:	80 83       	st	Z, r24

*/
DIO_enu_return_status_t DIO_enu_ReadChannel(DIO_enu_PinId_t arg_enu_pinId,u8 *ptr_value)
{
	//loc for return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     d42:	80 e0       	ldi	r24, 0x00	; 0
			
			case DIO_PORT_NUMBER_B :
			{
				// asign level 
				*ptr_value = GET_BIT(DIO_PINB,loc_u8_pinNumber);
				break;
     d44:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_C :
			{
				// asign level 
				*ptr_value = GET_BIT(DIO_PINC,loc_u8_pinNumber);
     d46:	83 b3       	in	r24, 0x13	; 19
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	02 c0       	rjmp	.+4      	; 0xd50 <DIO_enu_ReadChannel+0x60>
     d4c:	95 95       	asr	r25
     d4e:	87 95       	ror	r24
     d50:	2a 95       	dec	r18
     d52:	e2 f7       	brpl	.-8      	; 0xd4c <DIO_enu_ReadChannel+0x5c>
     d54:	81 70       	andi	r24, 0x01	; 1
     d56:	fb 01       	movw	r30, r22
     d58:	80 83       	st	Z, r24

*/
DIO_enu_return_status_t DIO_enu_ReadChannel(DIO_enu_PinId_t arg_enu_pinId,u8 *ptr_value)
{
	//loc for return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     d5a:	80 e0       	ldi	r24, 0x00	; 0
			
			case DIO_PORT_NUMBER_C :
			{
				// asign level 
				*ptr_value = GET_BIT(DIO_PINC,loc_u8_pinNumber);
				break;
     d5c:	08 95       	ret
			}
			
			case DIO_PORT_NUMBER_D :
			{
				// asign level 
				*ptr_value = GET_BIT(DIO_PIND,loc_u8_pinNumber);
     d5e:	80 b3       	in	r24, 0x10	; 16
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	02 c0       	rjmp	.+4      	; 0xd68 <DIO_enu_ReadChannel+0x78>
     d64:	95 95       	asr	r25
     d66:	87 95       	ror	r24
     d68:	2a 95       	dec	r18
     d6a:	e2 f7       	brpl	.-8      	; 0xd64 <DIO_enu_ReadChannel+0x74>
     d6c:	81 70       	andi	r24, 0x01	; 1
     d6e:	fb 01       	movw	r30, r22
     d70:	80 83       	st	Z, r24

*/
DIO_enu_return_status_t DIO_enu_ReadChannel(DIO_enu_PinId_t arg_enu_pinId,u8 *ptr_value)
{
	//loc for return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     d72:	80 e0       	ldi	r24, 0x00	; 0
			
			case DIO_PORT_NUMBER_D :
			{
				// asign level 
				*ptr_value = GET_BIT(DIO_PIND,loc_u8_pinNumber);
				break;
     d74:	08 95       	ret
	u8 loc_u8_portNumber = arg_enu_pinId / REG_SIZE ;
	
	// check if address is null
	if(ptr_value == PTR_NULL)
	{
		loc_enu_return_status = STATUS_DIO_NULL_PTR_ERROR;
     d76:	84 e0       	ldi	r24, 0x04	; 4
     d78:	08 95       	ret
	}
	// check on channel
	else if( arg_enu_pinId >= DIO_PINID_ERROR)
	{
		loc_enu_return_status = STATUS_DIO_PIN_NUMBER_ERROR;
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	08 95       	ret

*/
DIO_enu_return_status_t DIO_enu_ReadChannel(DIO_enu_PinId_t arg_enu_pinId,u8 *ptr_value)
{
	//loc for return status
	DIO_enu_return_status_t loc_enu_return_status = STATUS_DIO_OKAY;
     d7e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	
	
	return loc_enu_return_status;
}
     d80:	08 95       	ret

00000d82 <PORT_voidInit>:
	#undef  PORT_PIN_MODE_OUTPUT_HIGH
	#define PORT_PIN_MODE_OUTPUT_HIGH         1
	
	// set direction 
	
	DDRA = CONC(PORTA_PIN7_MODE,PORTA_PIN6_MODE,PORTA_PIN5_MODE,PORTA_PIN4_MODE,PORTA_PIN3_MODE,PORTA_PIN2_MODE,PORTA_PIN1_MODE,PORTA_PIN0_MODE);
     d82:	8e e0       	ldi	r24, 0x0E	; 14
     d84:	8a bb       	out	0x1a, r24	; 26
	DDRB = CONC(PORTB_PIN7_MODE,PORTB_PIN6_MODE,PORTB_PIN5_MODE,PORTB_PIN4_MODE,PORTB_PIN3_MODE,PORTB_PIN2_MODE,PORTB_PIN1_MODE,PORTB_PIN0_MODE);
     d86:	87 ed       	ldi	r24, 0xD7	; 215
     d88:	87 bb       	out	0x17, r24	; 23
	DDRC = CONC(PORTC_PIN7_MODE,PORTC_PIN6_MODE,PORTC_PIN5_MODE,PORTC_PIN4_MODE,PORTC_PIN3_MODE,PORTC_PIN2_MODE,PORTC_PIN1_MODE,PORTC_PIN0_MODE);
     d8a:	8c e7       	ldi	r24, 0x7C	; 124
     d8c:	84 bb       	out	0x14, r24	; 20
	DDRD = CONC(PORTD_PIN7_MODE,PORTD_PIN6_MODE,PORTD_PIN5_MODE,PORTD_PIN4_MODE,PORTD_PIN3_MODE,PORTD_PIN2_MODE,PORTD_PIN1_MODE,PORTD_PIN0_MODE);
     d8e:	11 ba       	out	0x11, r1	; 17
	#undef  PORT_PIN_MODE_OUTPUT_HIGH
	#define PORT_PIN_MODE_OUTPUT_HIGH         1
	
	// set mode
	
	PORTA = CONC(PORTA_PIN7_MODE,PORTA_PIN6_MODE,PORTA_PIN5_MODE,PORTA_PIN4_MODE,PORTA_PIN3_MODE,PORTA_PIN2_MODE,PORTA_PIN1_MODE,PORTA_PIN0_MODE);
     d90:	1b ba       	out	0x1b, r1	; 27
	PORTB = CONC(PORTB_PIN7_MODE,PORTB_PIN6_MODE,PORTB_PIN5_MODE,PORTB_PIN4_MODE,PORTB_PIN3_MODE,PORTB_PIN2_MODE,PORTB_PIN1_MODE,PORTB_PIN0_MODE);
     d92:	18 ba       	out	0x18, r1	; 24
	PORTC = CONC(PORTC_PIN7_MODE,PORTC_PIN6_MODE,PORTC_PIN5_MODE,PORTC_PIN4_MODE,PORTC_PIN3_MODE,PORTC_PIN2_MODE,PORTC_PIN1_MODE,PORTC_PIN0_MODE);
     d94:	8c e3       	ldi	r24, 0x3C	; 60
     d96:	85 bb       	out	0x15, r24	; 21
	PORTD = CONC(PORTD_PIN7_MODE,PORTD_PIN6_MODE,PORTD_PIN5_MODE,PORTD_PIN4_MODE,PORTD_PIN3_MODE,PORTD_PIN2_MODE,PORTD_PIN1_MODE,PORTD_PIN0_MODE);
     d98:	8c ee       	ldi	r24, 0xEC	; 236
     d9a:	82 bb       	out	0x12, r24	; 18
     d9c:	08 95       	ret

00000d9e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     da4:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     da8:	20 91 fb 00 	lds	r18, 0x00FB	; 0x8000fb <xNextFreeByte>
     dac:	30 91 fc 00 	lds	r19, 0x00FC	; 0x8000fc <xNextFreeByte+0x1>
     db0:	c9 01       	movw	r24, r18
     db2:	8c 0f       	add	r24, r28
     db4:	9d 1f       	adc	r25, r29
     db6:	88 3e       	cpi	r24, 0xE8	; 232
     db8:	43 e0       	ldi	r20, 0x03	; 3
     dba:	94 07       	cpc	r25, r20
     dbc:	58 f4       	brcc	.+22     	; 0xdd4 <pvPortMalloc+0x36>
     dbe:	28 17       	cp	r18, r24
     dc0:	39 07       	cpc	r19, r25
     dc2:	58 f4       	brcc	.+22     	; 0xdda <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     dc4:	e9 01       	movw	r28, r18
     dc6:	c3 50       	subi	r28, 0x03	; 3
     dc8:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     dca:	90 93 fc 00 	sts	0x00FC, r25	; 0x8000fc <xNextFreeByte+0x1>
     dce:	80 93 fb 00 	sts	0x00FB, r24	; 0x8000fb <xNextFreeByte>
     dd2:	05 c0       	rjmp	.+10     	; 0xdde <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     dd4:	c0 e0       	ldi	r28, 0x00	; 0
     dd6:	d0 e0       	ldi	r29, 0x00	; 0
     dd8:	02 c0       	rjmp	.+4      	; 0xdde <pvPortMalloc+0x40>
     dda:	c0 e0       	ldi	r28, 0x00	; 0
     ddc:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     dde:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     de2:	ce 01       	movw	r24, r28
     de4:	df 91       	pop	r29
     de6:	cf 91       	pop	r28
     de8:	08 95       	ret

00000dea <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     dea:	08 95       	ret

00000dec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     dec:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     dee:	03 96       	adiw	r24, 0x03	; 3
     df0:	92 83       	std	Z+2, r25	; 0x02
     df2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     df4:	2f ef       	ldi	r18, 0xFF	; 255
     df6:	3f ef       	ldi	r19, 0xFF	; 255
     df8:	34 83       	std	Z+4, r19	; 0x04
     dfa:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     dfc:	96 83       	std	Z+6, r25	; 0x06
     dfe:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     e00:	90 87       	std	Z+8, r25	; 0x08
     e02:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     e04:	10 82       	st	Z, r1
     e06:	08 95       	ret

00000e08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     e08:	fc 01       	movw	r30, r24
     e0a:	11 86       	std	Z+9, r1	; 0x09
     e0c:	10 86       	std	Z+8, r1	; 0x08
     e0e:	08 95       	ret

00000e10 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     e10:	cf 93       	push	r28
     e12:	df 93       	push	r29
     e14:	fc 01       	movw	r30, r24
     e16:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     e18:	21 81       	ldd	r18, Z+1	; 0x01
     e1a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     e1c:	e9 01       	movw	r28, r18
     e1e:	8a 81       	ldd	r24, Y+2	; 0x02
     e20:	9b 81       	ldd	r25, Y+3	; 0x03
     e22:	13 96       	adiw	r26, 0x03	; 3
     e24:	9c 93       	st	X, r25
     e26:	8e 93       	st	-X, r24
     e28:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     e2a:	81 81       	ldd	r24, Z+1	; 0x01
     e2c:	92 81       	ldd	r25, Z+2	; 0x02
     e2e:	15 96       	adiw	r26, 0x05	; 5
     e30:	9c 93       	st	X, r25
     e32:	8e 93       	st	-X, r24
     e34:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     e36:	8a 81       	ldd	r24, Y+2	; 0x02
     e38:	9b 81       	ldd	r25, Y+3	; 0x03
     e3a:	ec 01       	movw	r28, r24
     e3c:	7d 83       	std	Y+5, r23	; 0x05
     e3e:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     e40:	e9 01       	movw	r28, r18
     e42:	7b 83       	std	Y+3, r23	; 0x03
     e44:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     e46:	72 83       	std	Z+2, r23	; 0x02
     e48:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e4a:	19 96       	adiw	r26, 0x09	; 9
     e4c:	fc 93       	st	X, r31
     e4e:	ee 93       	st	-X, r30
     e50:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     e52:	80 81       	ld	r24, Z
     e54:	8f 5f       	subi	r24, 0xFF	; 255
     e56:	80 83       	st	Z, r24
}
     e58:	df 91       	pop	r29
     e5a:	cf 91       	pop	r28
     e5c:	08 95       	ret

00000e5e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     e5e:	cf 93       	push	r28
     e60:	df 93       	push	r29
     e62:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     e64:	48 81       	ld	r20, Y
     e66:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     e68:	4f 3f       	cpi	r20, 0xFF	; 255
     e6a:	2f ef       	ldi	r18, 0xFF	; 255
     e6c:	52 07       	cpc	r21, r18
     e6e:	31 f4       	brne	.+12     	; 0xe7c <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e70:	dc 01       	movw	r26, r24
     e72:	17 96       	adiw	r26, 0x07	; 7
     e74:	ed 91       	ld	r30, X+
     e76:	fc 91       	ld	r31, X
     e78:	18 97       	sbiw	r26, 0x08	; 8
     e7a:	0d c0       	rjmp	.+26     	; 0xe96 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     e7c:	fc 01       	movw	r30, r24
     e7e:	33 96       	adiw	r30, 0x03	; 3
     e80:	03 c0       	rjmp	.+6      	; 0xe88 <vListInsert+0x2a>
     e82:	02 80       	ldd	r0, Z+2	; 0x02
     e84:	f3 81       	ldd	r31, Z+3	; 0x03
     e86:	e0 2d       	mov	r30, r0
     e88:	a2 81       	ldd	r26, Z+2	; 0x02
     e8a:	b3 81       	ldd	r27, Z+3	; 0x03
     e8c:	2d 91       	ld	r18, X+
     e8e:	3c 91       	ld	r19, X
     e90:	42 17       	cp	r20, r18
     e92:	53 07       	cpc	r21, r19
     e94:	b0 f7       	brcc	.-20     	; 0xe82 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     e96:	a2 81       	ldd	r26, Z+2	; 0x02
     e98:	b3 81       	ldd	r27, Z+3	; 0x03
     e9a:	bb 83       	std	Y+3, r27	; 0x03
     e9c:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     e9e:	15 96       	adiw	r26, 0x05	; 5
     ea0:	dc 93       	st	X, r29
     ea2:	ce 93       	st	-X, r28
     ea4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     ea6:	fd 83       	std	Y+5, r31	; 0x05
     ea8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     eaa:	d3 83       	std	Z+3, r29	; 0x03
     eac:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     eae:	99 87       	std	Y+9, r25	; 0x09
     eb0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     eb2:	fc 01       	movw	r30, r24
     eb4:	20 81       	ld	r18, Z
     eb6:	2f 5f       	subi	r18, 0xFF	; 255
     eb8:	20 83       	st	Z, r18
}
     eba:	df 91       	pop	r29
     ebc:	cf 91       	pop	r28
     ebe:	08 95       	ret

00000ec0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     ec0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ec2:	a2 81       	ldd	r26, Z+2	; 0x02
     ec4:	b3 81       	ldd	r27, Z+3	; 0x03
     ec6:	84 81       	ldd	r24, Z+4	; 0x04
     ec8:	95 81       	ldd	r25, Z+5	; 0x05
     eca:	15 96       	adiw	r26, 0x05	; 5
     ecc:	9c 93       	st	X, r25
     ece:	8e 93       	st	-X, r24
     ed0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ed2:	a4 81       	ldd	r26, Z+4	; 0x04
     ed4:	b5 81       	ldd	r27, Z+5	; 0x05
     ed6:	82 81       	ldd	r24, Z+2	; 0x02
     ed8:	93 81       	ldd	r25, Z+3	; 0x03
     eda:	13 96       	adiw	r26, 0x03	; 3
     edc:	9c 93       	st	X, r25
     ede:	8e 93       	st	-X, r24
     ee0:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     ee2:	a0 85       	ldd	r26, Z+8	; 0x08
     ee4:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ee6:	11 96       	adiw	r26, 0x01	; 1
     ee8:	8d 91       	ld	r24, X+
     eea:	9c 91       	ld	r25, X
     eec:	12 97       	sbiw	r26, 0x02	; 2
     eee:	e8 17       	cp	r30, r24
     ef0:	f9 07       	cpc	r31, r25
     ef2:	31 f4       	brne	.+12     	; 0xf00 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ef4:	84 81       	ldd	r24, Z+4	; 0x04
     ef6:	95 81       	ldd	r25, Z+5	; 0x05
     ef8:	12 96       	adiw	r26, 0x02	; 2
     efa:	9c 93       	st	X, r25
     efc:	8e 93       	st	-X, r24
     efe:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     f00:	11 86       	std	Z+9, r1	; 0x09
     f02:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     f04:	8c 91       	ld	r24, X
     f06:	81 50       	subi	r24, 0x01	; 1
     f08:	8c 93       	st	X, r24
     f0a:	08 95       	ret

00000f0c <prvSetupTimerInterrupt>:
	portSAVE_CONTEXT();
	vTaskIncrementTick();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     f0c:	1b bc       	out	0x2b, r1	; 43
     f0e:	8c e7       	ldi	r24, 0x7C	; 124
     f10:	8a bd       	out	0x2a, r24	; 42
     f12:	8b e0       	ldi	r24, 0x0B	; 11
     f14:	8e bd       	out	0x2e, r24	; 46
     f16:	89 b7       	in	r24, 0x39	; 57
     f18:	80 61       	ori	r24, 0x10	; 16
     f1a:	89 bf       	out	0x39, r24	; 57
     f1c:	08 95       	ret

00000f1e <pxPortInitialiseStack>:
     f1e:	31 e1       	ldi	r19, 0x11	; 17
     f20:	fc 01       	movw	r30, r24
     f22:	30 83       	st	Z, r19
     f24:	31 97       	sbiw	r30, 0x01	; 1
     f26:	22 e2       	ldi	r18, 0x22	; 34
     f28:	20 83       	st	Z, r18
     f2a:	31 97       	sbiw	r30, 0x01	; 1
     f2c:	a3 e3       	ldi	r26, 0x33	; 51
     f2e:	a0 83       	st	Z, r26
     f30:	31 97       	sbiw	r30, 0x01	; 1
     f32:	60 83       	st	Z, r22
     f34:	31 97       	sbiw	r30, 0x01	; 1
     f36:	70 83       	st	Z, r23
     f38:	31 97       	sbiw	r30, 0x01	; 1
     f3a:	10 82       	st	Z, r1
     f3c:	31 97       	sbiw	r30, 0x01	; 1
     f3e:	60 e8       	ldi	r22, 0x80	; 128
     f40:	60 83       	st	Z, r22
     f42:	31 97       	sbiw	r30, 0x01	; 1
     f44:	10 82       	st	Z, r1
     f46:	31 97       	sbiw	r30, 0x01	; 1
     f48:	62 e0       	ldi	r22, 0x02	; 2
     f4a:	60 83       	st	Z, r22
     f4c:	31 97       	sbiw	r30, 0x01	; 1
     f4e:	63 e0       	ldi	r22, 0x03	; 3
     f50:	60 83       	st	Z, r22
     f52:	31 97       	sbiw	r30, 0x01	; 1
     f54:	64 e0       	ldi	r22, 0x04	; 4
     f56:	60 83       	st	Z, r22
     f58:	31 97       	sbiw	r30, 0x01	; 1
     f5a:	65 e0       	ldi	r22, 0x05	; 5
     f5c:	60 83       	st	Z, r22
     f5e:	31 97       	sbiw	r30, 0x01	; 1
     f60:	66 e0       	ldi	r22, 0x06	; 6
     f62:	60 83       	st	Z, r22
     f64:	31 97       	sbiw	r30, 0x01	; 1
     f66:	67 e0       	ldi	r22, 0x07	; 7
     f68:	60 83       	st	Z, r22
     f6a:	31 97       	sbiw	r30, 0x01	; 1
     f6c:	68 e0       	ldi	r22, 0x08	; 8
     f6e:	60 83       	st	Z, r22
     f70:	31 97       	sbiw	r30, 0x01	; 1
     f72:	69 e0       	ldi	r22, 0x09	; 9
     f74:	60 83       	st	Z, r22
     f76:	31 97       	sbiw	r30, 0x01	; 1
     f78:	60 e1       	ldi	r22, 0x10	; 16
     f7a:	60 83       	st	Z, r22
     f7c:	31 97       	sbiw	r30, 0x01	; 1
     f7e:	30 83       	st	Z, r19
     f80:	31 97       	sbiw	r30, 0x01	; 1
     f82:	32 e1       	ldi	r19, 0x12	; 18
     f84:	30 83       	st	Z, r19
     f86:	31 97       	sbiw	r30, 0x01	; 1
     f88:	33 e1       	ldi	r19, 0x13	; 19
     f8a:	30 83       	st	Z, r19
     f8c:	31 97       	sbiw	r30, 0x01	; 1
     f8e:	34 e1       	ldi	r19, 0x14	; 20
     f90:	30 83       	st	Z, r19
     f92:	31 97       	sbiw	r30, 0x01	; 1
     f94:	35 e1       	ldi	r19, 0x15	; 21
     f96:	30 83       	st	Z, r19
     f98:	31 97       	sbiw	r30, 0x01	; 1
     f9a:	36 e1       	ldi	r19, 0x16	; 22
     f9c:	30 83       	st	Z, r19
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	37 e1       	ldi	r19, 0x17	; 23
     fa2:	30 83       	st	Z, r19
     fa4:	31 97       	sbiw	r30, 0x01	; 1
     fa6:	38 e1       	ldi	r19, 0x18	; 24
     fa8:	30 83       	st	Z, r19
     faa:	31 97       	sbiw	r30, 0x01	; 1
     fac:	39 e1       	ldi	r19, 0x19	; 25
     fae:	30 83       	st	Z, r19
     fb0:	31 97       	sbiw	r30, 0x01	; 1
     fb2:	30 e2       	ldi	r19, 0x20	; 32
     fb4:	30 83       	st	Z, r19
     fb6:	31 97       	sbiw	r30, 0x01	; 1
     fb8:	31 e2       	ldi	r19, 0x21	; 33
     fba:	30 83       	st	Z, r19
     fbc:	31 97       	sbiw	r30, 0x01	; 1
     fbe:	20 83       	st	Z, r18
     fc0:	31 97       	sbiw	r30, 0x01	; 1
     fc2:	23 e2       	ldi	r18, 0x23	; 35
     fc4:	20 83       	st	Z, r18
     fc6:	31 97       	sbiw	r30, 0x01	; 1
     fc8:	40 83       	st	Z, r20
     fca:	31 97       	sbiw	r30, 0x01	; 1
     fcc:	50 83       	st	Z, r21
     fce:	31 97       	sbiw	r30, 0x01	; 1
     fd0:	26 e2       	ldi	r18, 0x26	; 38
     fd2:	20 83       	st	Z, r18
     fd4:	31 97       	sbiw	r30, 0x01	; 1
     fd6:	27 e2       	ldi	r18, 0x27	; 39
     fd8:	20 83       	st	Z, r18
     fda:	31 97       	sbiw	r30, 0x01	; 1
     fdc:	28 e2       	ldi	r18, 0x28	; 40
     fde:	20 83       	st	Z, r18
     fe0:	31 97       	sbiw	r30, 0x01	; 1
     fe2:	29 e2       	ldi	r18, 0x29	; 41
     fe4:	20 83       	st	Z, r18
     fe6:	31 97       	sbiw	r30, 0x01	; 1
     fe8:	20 e3       	ldi	r18, 0x30	; 48
     fea:	20 83       	st	Z, r18
     fec:	31 97       	sbiw	r30, 0x01	; 1
     fee:	21 e3       	ldi	r18, 0x31	; 49
     ff0:	20 83       	st	Z, r18
     ff2:	86 97       	sbiw	r24, 0x26	; 38
     ff4:	08 95       	ret

00000ff6 <xPortStartScheduler>:
     ff6:	0e 94 86 07 	call	0xf0c	; 0xf0c <prvSetupTimerInterrupt>
     ffa:	a0 91 46 05 	lds	r26, 0x0546	; 0x800546 <pxCurrentTCB>
     ffe:	b0 91 47 05 	lds	r27, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1002:	cd 91       	ld	r28, X+
    1004:	cd bf       	out	0x3d, r28	; 61
    1006:	dd 91       	ld	r29, X+
    1008:	de bf       	out	0x3e, r29	; 62
    100a:	ff 91       	pop	r31
    100c:	ef 91       	pop	r30
    100e:	df 91       	pop	r29
    1010:	cf 91       	pop	r28
    1012:	bf 91       	pop	r27
    1014:	af 91       	pop	r26
    1016:	9f 91       	pop	r25
    1018:	8f 91       	pop	r24
    101a:	7f 91       	pop	r23
    101c:	6f 91       	pop	r22
    101e:	5f 91       	pop	r21
    1020:	4f 91       	pop	r20
    1022:	3f 91       	pop	r19
    1024:	2f 91       	pop	r18
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	ff 90       	pop	r15
    102c:	ef 90       	pop	r14
    102e:	df 90       	pop	r13
    1030:	cf 90       	pop	r12
    1032:	bf 90       	pop	r11
    1034:	af 90       	pop	r10
    1036:	9f 90       	pop	r9
    1038:	8f 90       	pop	r8
    103a:	7f 90       	pop	r7
    103c:	6f 90       	pop	r6
    103e:	5f 90       	pop	r5
    1040:	4f 90       	pop	r4
    1042:	3f 90       	pop	r3
    1044:	2f 90       	pop	r2
    1046:	1f 90       	pop	r1
    1048:	0f 90       	pop	r0
    104a:	0f be       	out	0x3f, r0	; 63
    104c:	0f 90       	pop	r0
    104e:	08 95       	ret
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	08 95       	ret

00001054 <vPortYield>:
    1054:	0f 92       	push	r0
    1056:	0f b6       	in	r0, 0x3f	; 63
    1058:	f8 94       	cli
    105a:	0f 92       	push	r0
    105c:	1f 92       	push	r1
    105e:	11 24       	eor	r1, r1
    1060:	2f 92       	push	r2
    1062:	3f 92       	push	r3
    1064:	4f 92       	push	r4
    1066:	5f 92       	push	r5
    1068:	6f 92       	push	r6
    106a:	7f 92       	push	r7
    106c:	8f 92       	push	r8
    106e:	9f 92       	push	r9
    1070:	af 92       	push	r10
    1072:	bf 92       	push	r11
    1074:	cf 92       	push	r12
    1076:	df 92       	push	r13
    1078:	ef 92       	push	r14
    107a:	ff 92       	push	r15
    107c:	0f 93       	push	r16
    107e:	1f 93       	push	r17
    1080:	2f 93       	push	r18
    1082:	3f 93       	push	r19
    1084:	4f 93       	push	r20
    1086:	5f 93       	push	r21
    1088:	6f 93       	push	r22
    108a:	7f 93       	push	r23
    108c:	8f 93       	push	r24
    108e:	9f 93       	push	r25
    1090:	af 93       	push	r26
    1092:	bf 93       	push	r27
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
    1098:	ef 93       	push	r30
    109a:	ff 93       	push	r31
    109c:	a0 91 46 05 	lds	r26, 0x0546	; 0x800546 <pxCurrentTCB>
    10a0:	b0 91 47 05 	lds	r27, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    10a4:	0d b6       	in	r0, 0x3d	; 61
    10a6:	0d 92       	st	X+, r0
    10a8:	0e b6       	in	r0, 0x3e	; 62
    10aa:	0d 92       	st	X+, r0
    10ac:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <vTaskSwitchContext>
    10b0:	a0 91 46 05 	lds	r26, 0x0546	; 0x800546 <pxCurrentTCB>
    10b4:	b0 91 47 05 	lds	r27, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    10b8:	cd 91       	ld	r28, X+
    10ba:	cd bf       	out	0x3d, r28	; 61
    10bc:	dd 91       	ld	r29, X+
    10be:	de bf       	out	0x3e, r29	; 62
    10c0:	ff 91       	pop	r31
    10c2:	ef 91       	pop	r30
    10c4:	df 91       	pop	r29
    10c6:	cf 91       	pop	r28
    10c8:	bf 91       	pop	r27
    10ca:	af 91       	pop	r26
    10cc:	9f 91       	pop	r25
    10ce:	8f 91       	pop	r24
    10d0:	7f 91       	pop	r23
    10d2:	6f 91       	pop	r22
    10d4:	5f 91       	pop	r21
    10d6:	4f 91       	pop	r20
    10d8:	3f 91       	pop	r19
    10da:	2f 91       	pop	r18
    10dc:	1f 91       	pop	r17
    10de:	0f 91       	pop	r16
    10e0:	ff 90       	pop	r15
    10e2:	ef 90       	pop	r14
    10e4:	df 90       	pop	r13
    10e6:	cf 90       	pop	r12
    10e8:	bf 90       	pop	r11
    10ea:	af 90       	pop	r10
    10ec:	9f 90       	pop	r9
    10ee:	8f 90       	pop	r8
    10f0:	7f 90       	pop	r7
    10f2:	6f 90       	pop	r6
    10f4:	5f 90       	pop	r5
    10f6:	4f 90       	pop	r4
    10f8:	3f 90       	pop	r3
    10fa:	2f 90       	pop	r2
    10fc:	1f 90       	pop	r1
    10fe:	0f 90       	pop	r0
    1100:	0f be       	out	0x3f, r0	; 63
    1102:	0f 90       	pop	r0
    1104:	08 95       	ret

00001106 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void __vector_7( void ) __attribute__ ( ( signal ) );
	void __vector_7( void )
	{
    1106:	1f 92       	push	r1
    1108:	0f 92       	push	r0
    110a:	0f b6       	in	r0, 0x3f	; 63
    110c:	0f 92       	push	r0
    110e:	11 24       	eor	r1, r1
    1110:	2f 93       	push	r18
    1112:	3f 93       	push	r19
    1114:	4f 93       	push	r20
    1116:	5f 93       	push	r21
    1118:	6f 93       	push	r22
    111a:	7f 93       	push	r23
    111c:	8f 93       	push	r24
    111e:	9f 93       	push	r25
    1120:	af 93       	push	r26
    1122:	bf 93       	push	r27
    1124:	ef 93       	push	r30
    1126:	ff 93       	push	r31
		vTaskIncrementTick();
    1128:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <vTaskIncrementTick>
	}
    112c:	ff 91       	pop	r31
    112e:	ef 91       	pop	r30
    1130:	bf 91       	pop	r27
    1132:	af 91       	pop	r26
    1134:	9f 91       	pop	r25
    1136:	8f 91       	pop	r24
    1138:	7f 91       	pop	r23
    113a:	6f 91       	pop	r22
    113c:	5f 91       	pop	r21
    113e:	4f 91       	pop	r20
    1140:	3f 91       	pop	r19
    1142:	2f 91       	pop	r18
    1144:	0f 90       	pop	r0
    1146:	0f be       	out	0x3f, r0	; 63
    1148:	0f 90       	pop	r0
    114a:	1f 90       	pop	r1
    114c:	18 95       	reti

0000114e <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    114e:	0f b6       	in	r0, 0x3f	; 63
    1150:	f8 94       	cli
    1152:	0f 92       	push	r0
    1154:	fc 01       	movw	r30, r24
    1156:	92 8d       	ldd	r25, Z+26	; 0x1a
    1158:	81 e0       	ldi	r24, 0x01	; 1
    115a:	91 11       	cpse	r25, r1
    115c:	80 e0       	ldi	r24, 0x00	; 0
    115e:	0f 90       	pop	r0
    1160:	0f be       	out	0x3f, r0	; 63
    1162:	08 95       	ret

00001164 <prvIsQueueFull>:
    1164:	0f b6       	in	r0, 0x3f	; 63
    1166:	f8 94       	cli
    1168:	0f 92       	push	r0
    116a:	fc 01       	movw	r30, r24
    116c:	22 8d       	ldd	r18, Z+26	; 0x1a
    116e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1170:	81 e0       	ldi	r24, 0x01	; 1
    1172:	29 13       	cpse	r18, r25
    1174:	80 e0       	ldi	r24, 0x00	; 0
    1176:	0f 90       	pop	r0
    1178:	0f be       	out	0x3f, r0	; 63
    117a:	08 95       	ret

0000117c <prvCopyDataToQueue>:
    117c:	cf 93       	push	r28
    117e:	df 93       	push	r29
    1180:	ec 01       	movw	r28, r24
    1182:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1184:	88 23       	and	r24, r24
    1186:	a9 f1       	breq	.+106    	; 0x11f2 <prvCopyDataToQueue+0x76>
    1188:	41 11       	cpse	r20, r1
    118a:	17 c0       	rjmp	.+46     	; 0x11ba <prvCopyDataToQueue+0x3e>
    118c:	48 2f       	mov	r20, r24
    118e:	50 e0       	ldi	r21, 0x00	; 0
    1190:	8c 81       	ldd	r24, Y+4	; 0x04
    1192:	9d 81       	ldd	r25, Y+5	; 0x05
    1194:	0e 94 bf 10 	call	0x217e	; 0x217e <memcpy>
    1198:	2c 8d       	ldd	r18, Y+28	; 0x1c
    119a:	8c 81       	ldd	r24, Y+4	; 0x04
    119c:	9d 81       	ldd	r25, Y+5	; 0x05
    119e:	82 0f       	add	r24, r18
    11a0:	91 1d       	adc	r25, r1
    11a2:	9d 83       	std	Y+5, r25	; 0x05
    11a4:	8c 83       	std	Y+4, r24	; 0x04
    11a6:	2a 81       	ldd	r18, Y+2	; 0x02
    11a8:	3b 81       	ldd	r19, Y+3	; 0x03
    11aa:	82 17       	cp	r24, r18
    11ac:	93 07       	cpc	r25, r19
    11ae:	08 f1       	brcs	.+66     	; 0x11f2 <prvCopyDataToQueue+0x76>
    11b0:	88 81       	ld	r24, Y
    11b2:	99 81       	ldd	r25, Y+1	; 0x01
    11b4:	9d 83       	std	Y+5, r25	; 0x05
    11b6:	8c 83       	std	Y+4, r24	; 0x04
    11b8:	1c c0       	rjmp	.+56     	; 0x11f2 <prvCopyDataToQueue+0x76>
    11ba:	48 2f       	mov	r20, r24
    11bc:	50 e0       	ldi	r21, 0x00	; 0
    11be:	8e 81       	ldd	r24, Y+6	; 0x06
    11c0:	9f 81       	ldd	r25, Y+7	; 0x07
    11c2:	0e 94 bf 10 	call	0x217e	; 0x217e <memcpy>
    11c6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11c8:	90 e0       	ldi	r25, 0x00	; 0
    11ca:	91 95       	neg	r25
    11cc:	81 95       	neg	r24
    11ce:	91 09       	sbc	r25, r1
    11d0:	2e 81       	ldd	r18, Y+6	; 0x06
    11d2:	3f 81       	ldd	r19, Y+7	; 0x07
    11d4:	28 0f       	add	r18, r24
    11d6:	39 1f       	adc	r19, r25
    11d8:	3f 83       	std	Y+7, r19	; 0x07
    11da:	2e 83       	std	Y+6, r18	; 0x06
    11dc:	48 81       	ld	r20, Y
    11de:	59 81       	ldd	r21, Y+1	; 0x01
    11e0:	24 17       	cp	r18, r20
    11e2:	35 07       	cpc	r19, r21
    11e4:	30 f4       	brcc	.+12     	; 0x11f2 <prvCopyDataToQueue+0x76>
    11e6:	2a 81       	ldd	r18, Y+2	; 0x02
    11e8:	3b 81       	ldd	r19, Y+3	; 0x03
    11ea:	82 0f       	add	r24, r18
    11ec:	93 1f       	adc	r25, r19
    11ee:	9f 83       	std	Y+7, r25	; 0x07
    11f0:	8e 83       	std	Y+6, r24	; 0x06
    11f2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11f4:	8f 5f       	subi	r24, 0xFF	; 255
    11f6:	8a 8f       	std	Y+26, r24	; 0x1a
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	08 95       	ret

000011fe <prvCopyDataFromQueue>:
    11fe:	fc 01       	movw	r30, r24
    1200:	80 81       	ld	r24, Z
    1202:	91 81       	ldd	r25, Z+1	; 0x01
    1204:	00 97       	sbiw	r24, 0x00	; 0
    1206:	a1 f0       	breq	.+40     	; 0x1230 <prvCopyDataFromQueue+0x32>
    1208:	44 8d       	ldd	r20, Z+28	; 0x1c
    120a:	50 e0       	ldi	r21, 0x00	; 0
    120c:	26 81       	ldd	r18, Z+6	; 0x06
    120e:	37 81       	ldd	r19, Z+7	; 0x07
    1210:	24 0f       	add	r18, r20
    1212:	35 1f       	adc	r19, r21
    1214:	37 83       	std	Z+7, r19	; 0x07
    1216:	26 83       	std	Z+6, r18	; 0x06
    1218:	a2 81       	ldd	r26, Z+2	; 0x02
    121a:	b3 81       	ldd	r27, Z+3	; 0x03
    121c:	2a 17       	cp	r18, r26
    121e:	3b 07       	cpc	r19, r27
    1220:	10 f0       	brcs	.+4      	; 0x1226 <prvCopyDataFromQueue+0x28>
    1222:	97 83       	std	Z+7, r25	; 0x07
    1224:	86 83       	std	Z+6, r24	; 0x06
    1226:	cb 01       	movw	r24, r22
    1228:	66 81       	ldd	r22, Z+6	; 0x06
    122a:	77 81       	ldd	r23, Z+7	; 0x07
    122c:	0e 94 bf 10 	call	0x217e	; 0x217e <memcpy>
    1230:	08 95       	ret

00001232 <prvUnlockQueue>:
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	ec 01       	movw	r28, r24
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	0f 92       	push	r0
    123e:	0d c0       	rjmp	.+26     	; 0x125a <prvUnlockQueue+0x28>
    1240:	89 89       	ldd	r24, Y+17	; 0x11
    1242:	88 23       	and	r24, r24
    1244:	69 f0       	breq	.+26     	; 0x1260 <prvUnlockQueue+0x2e>
    1246:	ce 01       	movw	r24, r28
    1248:	41 96       	adiw	r24, 0x11	; 17
    124a:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <xTaskRemoveFromEventList>
    124e:	81 11       	cpse	r24, r1
    1250:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vTaskMissedYield>
    1254:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1256:	81 50       	subi	r24, 0x01	; 1
    1258:	8e 8f       	std	Y+30, r24	; 0x1e
    125a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    125c:	18 16       	cp	r1, r24
    125e:	84 f3       	brlt	.-32     	; 0x1240 <prvUnlockQueue+0xe>
    1260:	8f ef       	ldi	r24, 0xFF	; 255
    1262:	8e 8f       	std	Y+30, r24	; 0x1e
    1264:	0f 90       	pop	r0
    1266:	0f be       	out	0x3f, r0	; 63
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	0f 92       	push	r0
    126e:	0d c0       	rjmp	.+26     	; 0x128a <prvUnlockQueue+0x58>
    1270:	88 85       	ldd	r24, Y+8	; 0x08
    1272:	88 23       	and	r24, r24
    1274:	69 f0       	breq	.+26     	; 0x1290 <prvUnlockQueue+0x5e>
    1276:	ce 01       	movw	r24, r28
    1278:	08 96       	adiw	r24, 0x08	; 8
    127a:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <xTaskRemoveFromEventList>
    127e:	81 11       	cpse	r24, r1
    1280:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vTaskMissedYield>
    1284:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1286:	81 50       	subi	r24, 0x01	; 1
    1288:	8d 8f       	std	Y+29, r24	; 0x1d
    128a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    128c:	18 16       	cp	r1, r24
    128e:	84 f3       	brlt	.-32     	; 0x1270 <prvUnlockQueue+0x3e>
    1290:	8f ef       	ldi	r24, 0xFF	; 255
    1292:	8d 8f       	std	Y+29, r24	; 0x1d
    1294:	0f 90       	pop	r0
    1296:	0f be       	out	0x3f, r0	; 63
    1298:	df 91       	pop	r29
    129a:	cf 91       	pop	r28
    129c:	08 95       	ret

0000129e <xQueueCreate>:
    129e:	af 92       	push	r10
    12a0:	bf 92       	push	r11
    12a2:	cf 92       	push	r12
    12a4:	df 92       	push	r13
    12a6:	ef 92       	push	r14
    12a8:	ff 92       	push	r15
    12aa:	0f 93       	push	r16
    12ac:	1f 93       	push	r17
    12ae:	cf 93       	push	r28
    12b0:	df 93       	push	r29
    12b2:	88 23       	and	r24, r24
    12b4:	09 f4       	brne	.+2      	; 0x12b8 <xQueueCreate+0x1a>
    12b6:	45 c0       	rjmp	.+138    	; 0x1342 <xQueueCreate+0xa4>
    12b8:	06 2f       	mov	r16, r22
    12ba:	18 2f       	mov	r17, r24
    12bc:	8f e1       	ldi	r24, 0x1F	; 31
    12be:	90 e0       	ldi	r25, 0x00	; 0
    12c0:	0e 94 cf 06 	call	0xd9e	; 0xd9e <pvPortMalloc>
    12c4:	ec 01       	movw	r28, r24
    12c6:	89 2b       	or	r24, r25
    12c8:	f1 f1       	breq	.+124    	; 0x1346 <xQueueCreate+0xa8>
    12ca:	e1 2e       	mov	r14, r17
    12cc:	f1 2c       	mov	r15, r1
    12ce:	c0 2e       	mov	r12, r16
    12d0:	d1 2c       	mov	r13, r1
    12d2:	ec 9c       	mul	r14, r12
    12d4:	50 01       	movw	r10, r0
    12d6:	ed 9c       	mul	r14, r13
    12d8:	b0 0c       	add	r11, r0
    12da:	fc 9c       	mul	r15, r12
    12dc:	b0 0c       	add	r11, r0
    12de:	11 24       	eor	r1, r1
    12e0:	c5 01       	movw	r24, r10
    12e2:	01 96       	adiw	r24, 0x01	; 1
    12e4:	0e 94 cf 06 	call	0xd9e	; 0xd9e <pvPortMalloc>
    12e8:	99 83       	std	Y+1, r25	; 0x01
    12ea:	88 83       	st	Y, r24
    12ec:	00 97       	sbiw	r24, 0x00	; 0
    12ee:	19 f1       	breq	.+70     	; 0x1336 <xQueueCreate+0x98>
    12f0:	a8 0e       	add	r10, r24
    12f2:	b9 1e       	adc	r11, r25
    12f4:	bb 82       	std	Y+3, r11	; 0x03
    12f6:	aa 82       	std	Y+2, r10	; 0x02
    12f8:	1a 8e       	std	Y+26, r1	; 0x1a
    12fa:	9d 83       	std	Y+5, r25	; 0x05
    12fc:	8c 83       	std	Y+4, r24	; 0x04
    12fe:	21 e0       	ldi	r18, 0x01	; 1
    1300:	e2 1a       	sub	r14, r18
    1302:	f1 08       	sbc	r15, r1
    1304:	ce 9c       	mul	r12, r14
    1306:	90 01       	movw	r18, r0
    1308:	cf 9c       	mul	r12, r15
    130a:	30 0d       	add	r19, r0
    130c:	de 9c       	mul	r13, r14
    130e:	30 0d       	add	r19, r0
    1310:	11 24       	eor	r1, r1
    1312:	82 0f       	add	r24, r18
    1314:	93 1f       	adc	r25, r19
    1316:	9f 83       	std	Y+7, r25	; 0x07
    1318:	8e 83       	std	Y+6, r24	; 0x06
    131a:	1b 8f       	std	Y+27, r17	; 0x1b
    131c:	0c 8f       	std	Y+28, r16	; 0x1c
    131e:	8f ef       	ldi	r24, 0xFF	; 255
    1320:	8d 8f       	std	Y+29, r24	; 0x1d
    1322:	8e 8f       	std	Y+30, r24	; 0x1e
    1324:	ce 01       	movw	r24, r28
    1326:	08 96       	adiw	r24, 0x08	; 8
    1328:	0e 94 f6 06 	call	0xdec	; 0xdec <vListInitialise>
    132c:	ce 01       	movw	r24, r28
    132e:	41 96       	adiw	r24, 0x11	; 17
    1330:	0e 94 f6 06 	call	0xdec	; 0xdec <vListInitialise>
    1334:	08 c0       	rjmp	.+16     	; 0x1346 <xQueueCreate+0xa8>
    1336:	ce 01       	movw	r24, r28
    1338:	0e 94 f5 06 	call	0xdea	; 0xdea <vPortFree>
    133c:	c0 e0       	ldi	r28, 0x00	; 0
    133e:	d0 e0       	ldi	r29, 0x00	; 0
    1340:	02 c0       	rjmp	.+4      	; 0x1346 <xQueueCreate+0xa8>
    1342:	c0 e0       	ldi	r28, 0x00	; 0
    1344:	d0 e0       	ldi	r29, 0x00	; 0
    1346:	ce 01       	movw	r24, r28
    1348:	df 91       	pop	r29
    134a:	cf 91       	pop	r28
    134c:	1f 91       	pop	r17
    134e:	0f 91       	pop	r16
    1350:	ff 90       	pop	r15
    1352:	ef 90       	pop	r14
    1354:	df 90       	pop	r13
    1356:	cf 90       	pop	r12
    1358:	bf 90       	pop	r11
    135a:	af 90       	pop	r10
    135c:	08 95       	ret

0000135e <xQueueGenericSend>:
    135e:	cf 92       	push	r12
    1360:	df 92       	push	r13
    1362:	ef 92       	push	r14
    1364:	ff 92       	push	r15
    1366:	0f 93       	push	r16
    1368:	1f 93       	push	r17
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	00 d0       	rcall	.+0      	; 0x1370 <xQueueGenericSend+0x12>
    1370:	00 d0       	rcall	.+0      	; 0x1372 <xQueueGenericSend+0x14>
    1372:	1f 92       	push	r1
    1374:	cd b7       	in	r28, 0x3d	; 61
    1376:	de b7       	in	r29, 0x3e	; 62
    1378:	8c 01       	movw	r16, r24
    137a:	7b 01       	movw	r14, r22
    137c:	5d 83       	std	Y+5, r21	; 0x05
    137e:	4c 83       	std	Y+4, r20	; 0x04
    1380:	c2 2e       	mov	r12, r18
    1382:	d1 2c       	mov	r13, r1
    1384:	0f b6       	in	r0, 0x3f	; 63
    1386:	f8 94       	cli
    1388:	0f 92       	push	r0
    138a:	f8 01       	movw	r30, r16
    138c:	92 8d       	ldd	r25, Z+26	; 0x1a
    138e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1390:	98 17       	cp	r25, r24
    1392:	a8 f4       	brcc	.+42     	; 0x13be <xQueueGenericSend+0x60>
    1394:	4c 2d       	mov	r20, r12
    1396:	b7 01       	movw	r22, r14
    1398:	c8 01       	movw	r24, r16
    139a:	0e 94 be 08 	call	0x117c	; 0x117c <prvCopyDataToQueue>
    139e:	f8 01       	movw	r30, r16
    13a0:	81 89       	ldd	r24, Z+17	; 0x11
    13a2:	88 23       	and	r24, r24
    13a4:	41 f0       	breq	.+16     	; 0x13b6 <xQueueGenericSend+0x58>
    13a6:	c8 01       	movw	r24, r16
    13a8:	41 96       	adiw	r24, 0x11	; 17
    13aa:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <xTaskRemoveFromEventList>
    13ae:	81 30       	cpi	r24, 0x01	; 1
    13b0:	11 f4       	brne	.+4      	; 0x13b6 <xQueueGenericSend+0x58>
    13b2:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
    13b6:	0f 90       	pop	r0
    13b8:	0f be       	out	0x3f, r0	; 63
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	4d c0       	rjmp	.+154    	; 0x1458 <xQueueGenericSend+0xfa>
    13be:	8c 81       	ldd	r24, Y+4	; 0x04
    13c0:	9d 81       	ldd	r25, Y+5	; 0x05
    13c2:	89 2b       	or	r24, r25
    13c4:	21 f4       	brne	.+8      	; 0x13ce <xQueueGenericSend+0x70>
    13c6:	0f 90       	pop	r0
    13c8:	0f be       	out	0x3f, r0	; 63
    13ca:	80 e0       	ldi	r24, 0x00	; 0
    13cc:	45 c0       	rjmp	.+138    	; 0x1458 <xQueueGenericSend+0xfa>
    13ce:	d1 10       	cpse	r13, r1
    13d0:	06 c0       	rjmp	.+12     	; 0x13de <xQueueGenericSend+0x80>
    13d2:	ce 01       	movw	r24, r28
    13d4:	01 96       	adiw	r24, 0x01	; 1
    13d6:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <vTaskSetTimeOutState>
    13da:	dd 24       	eor	r13, r13
    13dc:	d3 94       	inc	r13
    13de:	0f 90       	pop	r0
    13e0:	0f be       	out	0x3f, r0	; 63
    13e2:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <vTaskSuspendAll>
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	f8 94       	cli
    13ea:	0f 92       	push	r0
    13ec:	f8 01       	movw	r30, r16
    13ee:	85 8d       	ldd	r24, Z+29	; 0x1d
    13f0:	8f 3f       	cpi	r24, 0xFF	; 255
    13f2:	09 f4       	brne	.+2      	; 0x13f6 <xQueueGenericSend+0x98>
    13f4:	15 8e       	std	Z+29, r1	; 0x1d
    13f6:	f8 01       	movw	r30, r16
    13f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    13fa:	8f 3f       	cpi	r24, 0xFF	; 255
    13fc:	09 f4       	brne	.+2      	; 0x1400 <xQueueGenericSend+0xa2>
    13fe:	16 8e       	std	Z+30, r1	; 0x1e
    1400:	0f 90       	pop	r0
    1402:	0f be       	out	0x3f, r0	; 63
    1404:	be 01       	movw	r22, r28
    1406:	6c 5f       	subi	r22, 0xFC	; 252
    1408:	7f 4f       	sbci	r23, 0xFF	; 255
    140a:	ce 01       	movw	r24, r28
    140c:	01 96       	adiw	r24, 0x01	; 1
    140e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <xTaskCheckForTimeOut>
    1412:	81 11       	cpse	r24, r1
    1414:	1b c0       	rjmp	.+54     	; 0x144c <xQueueGenericSend+0xee>
    1416:	c8 01       	movw	r24, r16
    1418:	0e 94 b2 08 	call	0x1164	; 0x1164 <prvIsQueueFull>
    141c:	88 23       	and	r24, r24
    141e:	81 f0       	breq	.+32     	; 0x1440 <xQueueGenericSend+0xe2>
    1420:	6c 81       	ldd	r22, Y+4	; 0x04
    1422:	7d 81       	ldd	r23, Y+5	; 0x05
    1424:	c8 01       	movw	r24, r16
    1426:	08 96       	adiw	r24, 0x08	; 8
    1428:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vTaskPlaceOnEventList>
    142c:	c8 01       	movw	r24, r16
    142e:	0e 94 19 09 	call	0x1232	; 0x1232 <prvUnlockQueue>
    1432:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>
    1436:	81 11       	cpse	r24, r1
    1438:	a5 cf       	rjmp	.-182    	; 0x1384 <xQueueGenericSend+0x26>
    143a:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
    143e:	a2 cf       	rjmp	.-188    	; 0x1384 <xQueueGenericSend+0x26>
    1440:	c8 01       	movw	r24, r16
    1442:	0e 94 19 09 	call	0x1232	; 0x1232 <prvUnlockQueue>
    1446:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>
    144a:	9c cf       	rjmp	.-200    	; 0x1384 <xQueueGenericSend+0x26>
    144c:	c8 01       	movw	r24, r16
    144e:	0e 94 19 09 	call	0x1232	; 0x1232 <prvUnlockQueue>
    1452:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>
    1456:	80 e0       	ldi	r24, 0x00	; 0
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	df 91       	pop	r29
    1464:	cf 91       	pop	r28
    1466:	1f 91       	pop	r17
    1468:	0f 91       	pop	r16
    146a:	ff 90       	pop	r15
    146c:	ef 90       	pop	r14
    146e:	df 90       	pop	r13
    1470:	cf 90       	pop	r12
    1472:	08 95       	ret

00001474 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1474:	af 92       	push	r10
    1476:	bf 92       	push	r11
    1478:	cf 92       	push	r12
    147a:	df 92       	push	r13
    147c:	ef 92       	push	r14
    147e:	ff 92       	push	r15
    1480:	0f 93       	push	r16
    1482:	1f 93       	push	r17
    1484:	cf 93       	push	r28
    1486:	df 93       	push	r29
    1488:	00 d0       	rcall	.+0      	; 0x148a <xQueueGenericReceive+0x16>
    148a:	00 d0       	rcall	.+0      	; 0x148c <xQueueGenericReceive+0x18>
    148c:	1f 92       	push	r1
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
    1492:	8c 01       	movw	r16, r24
    1494:	6b 01       	movw	r12, r22
    1496:	5d 83       	std	Y+5, r21	; 0x05
    1498:	4c 83       	std	Y+4, r20	; 0x04
    149a:	e2 2e       	mov	r14, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    149c:	f1 2c       	mov	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	f8 94       	cli
    14a2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    14a4:	f8 01       	movw	r30, r16
    14a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    14a8:	88 23       	and	r24, r24
    14aa:	49 f1       	breq	.+82     	; 0x14fe <xQueueGenericReceive+0x8a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    14ac:	a6 80       	ldd	r10, Z+6	; 0x06
    14ae:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    14b0:	b6 01       	movw	r22, r12
    14b2:	c8 01       	movw	r24, r16
    14b4:	0e 94 ff 08 	call	0x11fe	; 0x11fe <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    14b8:	e1 10       	cpse	r14, r1
    14ba:	10 c0       	rjmp	.+32     	; 0x14dc <xQueueGenericReceive+0x68>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    14bc:	f8 01       	movw	r30, r16
    14be:	82 8d       	ldd	r24, Z+26	; 0x1a
    14c0:	81 50       	subi	r24, 0x01	; 1
    14c2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14c4:	80 85       	ldd	r24, Z+8	; 0x08
    14c6:	88 23       	and	r24, r24
    14c8:	b1 f0       	breq	.+44     	; 0x14f6 <xQueueGenericReceive+0x82>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    14ca:	c8 01       	movw	r24, r16
    14cc:	08 96       	adiw	r24, 0x08	; 8
    14ce:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <xTaskRemoveFromEventList>
    14d2:	81 30       	cpi	r24, 0x01	; 1
    14d4:	81 f4       	brne	.+32     	; 0x14f6 <xQueueGenericReceive+0x82>
						{
							portYIELD_WITHIN_API();
    14d6:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
    14da:	0d c0       	rjmp	.+26     	; 0x14f6 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    14dc:	f8 01       	movw	r30, r16
    14de:	b7 82       	std	Z+7, r11	; 0x07
    14e0:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14e2:	81 89       	ldd	r24, Z+17	; 0x11
    14e4:	88 23       	and	r24, r24
    14e6:	39 f0       	breq	.+14     	; 0x14f6 <xQueueGenericReceive+0x82>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14e8:	c8 01       	movw	r24, r16
    14ea:	41 96       	adiw	r24, 0x11	; 17
    14ec:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <xTaskRemoveFromEventList>
    14f0:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    14f2:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    14f6:	0f 90       	pop	r0
    14f8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    14fa:	81 e0       	ldi	r24, 0x01	; 1
    14fc:	4d c0       	rjmp	.+154    	; 0x1598 <xQueueGenericReceive+0x124>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    14fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1500:	9d 81       	ldd	r25, Y+5	; 0x05
    1502:	89 2b       	or	r24, r25
    1504:	21 f4       	brne	.+8      	; 0x150e <xQueueGenericReceive+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1506:	0f 90       	pop	r0
    1508:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    150a:	80 e0       	ldi	r24, 0x00	; 0
    150c:	45 c0       	rjmp	.+138    	; 0x1598 <xQueueGenericReceive+0x124>
				}
				else if( xEntryTimeSet == pdFALSE )
    150e:	f1 10       	cpse	r15, r1
    1510:	06 c0       	rjmp	.+12     	; 0x151e <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1512:	ce 01       	movw	r24, r28
    1514:	01 96       	adiw	r24, 0x01	; 1
    1516:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    151a:	ff 24       	eor	r15, r15
    151c:	f3 94       	inc	r15
				}
			}
		}
		taskEXIT_CRITICAL();
    151e:	0f 90       	pop	r0
    1520:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1522:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1526:	0f b6       	in	r0, 0x3f	; 63
    1528:	f8 94       	cli
    152a:	0f 92       	push	r0
    152c:	f8 01       	movw	r30, r16
    152e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1530:	8f 3f       	cpi	r24, 0xFF	; 255
    1532:	09 f4       	brne	.+2      	; 0x1536 <xQueueGenericReceive+0xc2>
    1534:	15 8e       	std	Z+29, r1	; 0x1d
    1536:	f8 01       	movw	r30, r16
    1538:	86 8d       	ldd	r24, Z+30	; 0x1e
    153a:	8f 3f       	cpi	r24, 0xFF	; 255
    153c:	09 f4       	brne	.+2      	; 0x1540 <xQueueGenericReceive+0xcc>
    153e:	16 8e       	std	Z+30, r1	; 0x1e
    1540:	0f 90       	pop	r0
    1542:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1544:	be 01       	movw	r22, r28
    1546:	6c 5f       	subi	r22, 0xFC	; 252
    1548:	7f 4f       	sbci	r23, 0xFF	; 255
    154a:	ce 01       	movw	r24, r28
    154c:	01 96       	adiw	r24, 0x01	; 1
    154e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <xTaskCheckForTimeOut>
    1552:	81 11       	cpse	r24, r1
    1554:	1b c0       	rjmp	.+54     	; 0x158c <xQueueGenericReceive+0x118>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1556:	c8 01       	movw	r24, r16
    1558:	0e 94 a7 08 	call	0x114e	; 0x114e <prvIsQueueEmpty>
    155c:	88 23       	and	r24, r24
    155e:	81 f0       	breq	.+32     	; 0x1580 <xQueueGenericReceive+0x10c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1560:	6c 81       	ldd	r22, Y+4	; 0x04
    1562:	7d 81       	ldd	r23, Y+5	; 0x05
    1564:	c8 01       	movw	r24, r16
    1566:	41 96       	adiw	r24, 0x11	; 17
    1568:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    156c:	c8 01       	movw	r24, r16
    156e:	0e 94 19 09 	call	0x1232	; 0x1232 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1572:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>
    1576:	81 11       	cpse	r24, r1
    1578:	92 cf       	rjmp	.-220    	; 0x149e <xQueueGenericReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    157a:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
    157e:	8f cf       	rjmp	.-226    	; 0x149e <xQueueGenericReceive+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1580:	c8 01       	movw	r24, r16
    1582:	0e 94 19 09 	call	0x1232	; 0x1232 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1586:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>
    158a:	89 cf       	rjmp	.-238    	; 0x149e <xQueueGenericReceive+0x2a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    158c:	c8 01       	movw	r24, r16
    158e:	0e 94 19 09 	call	0x1232	; 0x1232 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1592:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1596:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1598:	0f 90       	pop	r0
    159a:	0f 90       	pop	r0
    159c:	0f 90       	pop	r0
    159e:	0f 90       	pop	r0
    15a0:	0f 90       	pop	r0
    15a2:	df 91       	pop	r29
    15a4:	cf 91       	pop	r28
    15a6:	1f 91       	pop	r17
    15a8:	0f 91       	pop	r16
    15aa:	ff 90       	pop	r15
    15ac:	ef 90       	pop	r14
    15ae:	df 90       	pop	r13
    15b0:	cf 90       	pop	r12
    15b2:	bf 90       	pop	r11
    15b4:	af 90       	pop	r10
    15b6:	08 95       	ret

000015b8 <prvDeleteTCB>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    15b8:	cf 93       	push	r28
    15ba:	df 93       	push	r29
    15bc:	ec 01       	movw	r28, r24
    15be:	8f 89       	ldd	r24, Y+23	; 0x17
    15c0:	98 8d       	ldd	r25, Y+24	; 0x18
    15c2:	0e 94 f5 06 	call	0xdea	; 0xdea <vPortFree>
    15c6:	ce 01       	movw	r24, r28
    15c8:	0e 94 f5 06 	call	0xdea	; 0xdea <vPortFree>
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	08 95       	ret

000015d2 <prvAllocateTCBAndStack>:
    15d2:	ef 92       	push	r14
    15d4:	ff 92       	push	r15
    15d6:	0f 93       	push	r16
    15d8:	1f 93       	push	r17
    15da:	cf 93       	push	r28
    15dc:	df 93       	push	r29
    15de:	7c 01       	movw	r14, r24
    15e0:	eb 01       	movw	r28, r22
    15e2:	81 e2       	ldi	r24, 0x21	; 33
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	0e 94 cf 06 	call	0xd9e	; 0xd9e <pvPortMalloc>
    15ea:	8c 01       	movw	r16, r24
    15ec:	89 2b       	or	r24, r25
    15ee:	b9 f0       	breq	.+46     	; 0x161e <prvAllocateTCBAndStack+0x4c>
    15f0:	20 97       	sbiw	r28, 0x00	; 0
    15f2:	21 f4       	brne	.+8      	; 0x15fc <prvAllocateTCBAndStack+0x2a>
    15f4:	c7 01       	movw	r24, r14
    15f6:	0e 94 cf 06 	call	0xd9e	; 0xd9e <pvPortMalloc>
    15fa:	01 c0       	rjmp	.+2      	; 0x15fe <prvAllocateTCBAndStack+0x2c>
    15fc:	ce 01       	movw	r24, r28
    15fe:	f8 01       	movw	r30, r16
    1600:	90 8f       	std	Z+24, r25	; 0x18
    1602:	87 8b       	std	Z+23, r24	; 0x17
    1604:	00 97       	sbiw	r24, 0x00	; 0
    1606:	31 f4       	brne	.+12     	; 0x1614 <prvAllocateTCBAndStack+0x42>
    1608:	c8 01       	movw	r24, r16
    160a:	0e 94 f5 06 	call	0xdea	; 0xdea <vPortFree>
    160e:	00 e0       	ldi	r16, 0x00	; 0
    1610:	10 e0       	ldi	r17, 0x00	; 0
    1612:	05 c0       	rjmp	.+10     	; 0x161e <prvAllocateTCBAndStack+0x4c>
    1614:	a7 01       	movw	r20, r14
    1616:	65 ea       	ldi	r22, 0xA5	; 165
    1618:	70 e0       	ldi	r23, 0x00	; 0
    161a:	0e 94 c8 10 	call	0x2190	; 0x2190 <memset>
    161e:	c8 01       	movw	r24, r16
    1620:	df 91       	pop	r29
    1622:	cf 91       	pop	r28
    1624:	1f 91       	pop	r17
    1626:	0f 91       	pop	r16
    1628:	ff 90       	pop	r15
    162a:	ef 90       	pop	r14
    162c:	08 95       	ret

0000162e <prvInitialiseTCBVariables>:
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	ec 01       	movw	r28, r24
    1636:	14 2f       	mov	r17, r20
    1638:	48 e0       	ldi	r20, 0x08	; 8
    163a:	50 e0       	ldi	r21, 0x00	; 0
    163c:	49 96       	adiw	r24, 0x19	; 25
    163e:	0e 94 cf 10 	call	0x219e	; 0x219e <strncpy>
    1642:	18 a2       	std	Y+32, r1	; 0x20
    1644:	15 30       	cpi	r17, 0x05	; 5
    1646:	08 f0       	brcs	.+2      	; 0x164a <prvInitialiseTCBVariables+0x1c>
    1648:	14 e0       	ldi	r17, 0x04	; 4
    164a:	1e 8b       	std	Y+22, r17	; 0x16
    164c:	ce 01       	movw	r24, r28
    164e:	02 96       	adiw	r24, 0x02	; 2
    1650:	0e 94 04 07 	call	0xe08	; 0xe08 <vListInitialiseItem>
    1654:	ce 01       	movw	r24, r28
    1656:	0c 96       	adiw	r24, 0x0c	; 12
    1658:	0e 94 04 07 	call	0xe08	; 0xe08 <vListInitialiseItem>
    165c:	d9 87       	std	Y+9, r29	; 0x09
    165e:	c8 87       	std	Y+8, r28	; 0x08
    1660:	85 e0       	ldi	r24, 0x05	; 5
    1662:	90 e0       	ldi	r25, 0x00	; 0
    1664:	81 1b       	sub	r24, r17
    1666:	91 09       	sbc	r25, r1
    1668:	9d 87       	std	Y+13, r25	; 0x0d
    166a:	8c 87       	std	Y+12, r24	; 0x0c
    166c:	db 8b       	std	Y+19, r29	; 0x13
    166e:	ca 8b       	std	Y+18, r28	; 0x12
    1670:	df 91       	pop	r29
    1672:	cf 91       	pop	r28
    1674:	1f 91       	pop	r17
    1676:	08 95       	ret

00001678 <prvInitialiseTaskLists>:
    1678:	cf 93       	push	r28
    167a:	c0 e0       	ldi	r28, 0x00	; 0
    167c:	10 c0       	rjmp	.+32     	; 0x169e <prvInitialiseTaskLists+0x26>
    167e:	8c 2f       	mov	r24, r28
    1680:	90 e0       	ldi	r25, 0x00	; 0
    1682:	9c 01       	movw	r18, r24
    1684:	22 0f       	add	r18, r18
    1686:	33 1f       	adc	r19, r19
    1688:	22 0f       	add	r18, r18
    168a:	33 1f       	adc	r19, r19
    168c:	22 0f       	add	r18, r18
    168e:	33 1f       	adc	r19, r19
    1690:	82 0f       	add	r24, r18
    1692:	93 1f       	adc	r25, r19
    1694:	87 5e       	subi	r24, 0xE7	; 231
    1696:	9a 4f       	sbci	r25, 0xFA	; 250
    1698:	0e 94 f6 06 	call	0xdec	; 0xdec <vListInitialise>
    169c:	cf 5f       	subi	r28, 0xFF	; 255
    169e:	c5 30       	cpi	r28, 0x05	; 5
    16a0:	70 f3       	brcs	.-36     	; 0x167e <prvInitialiseTaskLists+0x6>
    16a2:	80 e1       	ldi	r24, 0x10	; 16
    16a4:	95 e0       	ldi	r25, 0x05	; 5
    16a6:	0e 94 f6 06 	call	0xdec	; 0xdec <vListInitialise>
    16aa:	87 e0       	ldi	r24, 0x07	; 7
    16ac:	95 e0       	ldi	r25, 0x05	; 5
    16ae:	0e 94 f6 06 	call	0xdec	; 0xdec <vListInitialise>
    16b2:	8a ef       	ldi	r24, 0xFA	; 250
    16b4:	94 e0       	ldi	r25, 0x04	; 4
    16b6:	0e 94 f6 06 	call	0xdec	; 0xdec <vListInitialise>
    16ba:	81 ef       	ldi	r24, 0xF1	; 241
    16bc:	94 e0       	ldi	r25, 0x04	; 4
    16be:	0e 94 f6 06 	call	0xdec	; 0xdec <vListInitialise>
    16c2:	80 e1       	ldi	r24, 0x10	; 16
    16c4:	95 e0       	ldi	r25, 0x05	; 5
    16c6:	90 93 06 05 	sts	0x0506, r25	; 0x800506 <pxDelayedTaskList+0x1>
    16ca:	80 93 05 05 	sts	0x0505, r24	; 0x800505 <pxDelayedTaskList>
    16ce:	87 e0       	ldi	r24, 0x07	; 7
    16d0:	95 e0       	ldi	r25, 0x05	; 5
    16d2:	90 93 04 05 	sts	0x0504, r25	; 0x800504 <pxOverflowDelayedTaskList+0x1>
    16d6:	80 93 03 05 	sts	0x0503, r24	; 0x800503 <pxOverflowDelayedTaskList>
    16da:	cf 91       	pop	r28
    16dc:	08 95       	ret

000016de <prvAddCurrentTaskToDelayedList>:
    16de:	cf 93       	push	r28
    16e0:	df 93       	push	r29
    16e2:	ec 01       	movw	r28, r24
    16e4:	e0 91 46 05 	lds	r30, 0x0546	; 0x800546 <pxCurrentTCB>
    16e8:	f0 91 47 05 	lds	r31, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    16ec:	93 83       	std	Z+3, r25	; 0x03
    16ee:	82 83       	std	Z+2, r24	; 0x02
    16f0:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <xTickCount>
    16f4:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <xTickCount+0x1>
    16f8:	c8 17       	cp	r28, r24
    16fa:	d9 07       	cpc	r29, r25
    16fc:	68 f4       	brcc	.+26     	; 0x1718 <prvAddCurrentTaskToDelayedList+0x3a>
    16fe:	60 91 46 05 	lds	r22, 0x0546	; 0x800546 <pxCurrentTCB>
    1702:	70 91 47 05 	lds	r23, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1706:	80 91 03 05 	lds	r24, 0x0503	; 0x800503 <pxOverflowDelayedTaskList>
    170a:	90 91 04 05 	lds	r25, 0x0504	; 0x800504 <pxOverflowDelayedTaskList+0x1>
    170e:	6e 5f       	subi	r22, 0xFE	; 254
    1710:	7f 4f       	sbci	r23, 0xFF	; 255
    1712:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>
    1716:	17 c0       	rjmp	.+46     	; 0x1746 <prvAddCurrentTaskToDelayedList+0x68>
    1718:	60 91 46 05 	lds	r22, 0x0546	; 0x800546 <pxCurrentTCB>
    171c:	70 91 47 05 	lds	r23, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1720:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <pxDelayedTaskList>
    1724:	90 91 06 05 	lds	r25, 0x0506	; 0x800506 <pxDelayedTaskList+0x1>
    1728:	6e 5f       	subi	r22, 0xFE	; 254
    172a:	7f 4f       	sbci	r23, 0xFF	; 255
    172c:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>
    1730:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <xNextTaskUnblockTime>
    1734:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <xNextTaskUnblockTime+0x1>
    1738:	c8 17       	cp	r28, r24
    173a:	d9 07       	cpc	r29, r25
    173c:	20 f4       	brcc	.+8      	; 0x1746 <prvAddCurrentTaskToDelayedList+0x68>
    173e:	d0 93 87 00 	sts	0x0087, r29	; 0x800087 <xNextTaskUnblockTime+0x1>
    1742:	c0 93 86 00 	sts	0x0086, r28	; 0x800086 <xNextTaskUnblockTime>
    1746:	df 91       	pop	r29
    1748:	cf 91       	pop	r28
    174a:	08 95       	ret

0000174c <xTaskGenericCreate>:
    174c:	2f 92       	push	r2
    174e:	3f 92       	push	r3
    1750:	4f 92       	push	r4
    1752:	5f 92       	push	r5
    1754:	7f 92       	push	r7
    1756:	8f 92       	push	r8
    1758:	9f 92       	push	r9
    175a:	af 92       	push	r10
    175c:	bf 92       	push	r11
    175e:	cf 92       	push	r12
    1760:	df 92       	push	r13
    1762:	ef 92       	push	r14
    1764:	ff 92       	push	r15
    1766:	0f 93       	push	r16
    1768:	1f 93       	push	r17
    176a:	cf 93       	push	r28
    176c:	df 93       	push	r29
    176e:	00 d0       	rcall	.+0      	; 0x1770 <xTaskGenericCreate+0x24>
    1770:	00 d0       	rcall	.+0      	; 0x1772 <xTaskGenericCreate+0x26>
    1772:	cd b7       	in	r28, 0x3d	; 61
    1774:	de b7       	in	r29, 0x3e	; 62
    1776:	9a 83       	std	Y+2, r25	; 0x02
    1778:	89 83       	std	Y+1, r24	; 0x01
    177a:	4b 01       	movw	r8, r22
    177c:	5c 83       	std	Y+4, r21	; 0x04
    177e:	4b 83       	std	Y+3, r20	; 0x03
    1780:	19 01       	movw	r2, r18
    1782:	70 2e       	mov	r7, r16
    1784:	b6 01       	movw	r22, r12
    1786:	25 01       	movw	r4, r10
    1788:	ca 01       	movw	r24, r20
    178a:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <prvAllocateTCBAndStack>
    178e:	5c 01       	movw	r10, r24
    1790:	00 97       	sbiw	r24, 0x00	; 0
    1792:	09 f4       	brne	.+2      	; 0x1796 <xTaskGenericCreate+0x4a>
    1794:	70 c0       	rjmp	.+224    	; 0x1876 <xTaskGenericCreate+0x12a>
    1796:	fc 01       	movw	r30, r24
    1798:	c7 88       	ldd	r12, Z+23	; 0x17
    179a:	d0 8c       	ldd	r13, Z+24	; 0x18
    179c:	8b 81       	ldd	r24, Y+3	; 0x03
    179e:	9c 81       	ldd	r25, Y+4	; 0x04
    17a0:	01 97       	sbiw	r24, 0x01	; 1
    17a2:	c8 0e       	add	r12, r24
    17a4:	d9 1e       	adc	r13, r25
    17a6:	0b 81       	ldd	r16, Y+3	; 0x03
    17a8:	1c 81       	ldd	r17, Y+4	; 0x04
    17aa:	92 01       	movw	r18, r4
    17ac:	47 2d       	mov	r20, r7
    17ae:	b4 01       	movw	r22, r8
    17b0:	c5 01       	movw	r24, r10
    17b2:	0e 94 17 0b 	call	0x162e	; 0x162e <prvInitialiseTCBVariables>
    17b6:	a1 01       	movw	r20, r2
    17b8:	69 81       	ldd	r22, Y+1	; 0x01
    17ba:	7a 81       	ldd	r23, Y+2	; 0x02
    17bc:	c6 01       	movw	r24, r12
    17be:	0e 94 8f 07 	call	0xf1e	; 0xf1e <pxPortInitialiseStack>
    17c2:	f5 01       	movw	r30, r10
    17c4:	91 83       	std	Z+1, r25	; 0x01
    17c6:	80 83       	st	Z, r24
    17c8:	e1 14       	cp	r14, r1
    17ca:	f1 04       	cpc	r15, r1
    17cc:	19 f0       	breq	.+6      	; 0x17d4 <xTaskGenericCreate+0x88>
    17ce:	f7 01       	movw	r30, r14
    17d0:	b1 82       	std	Z+1, r11	; 0x01
    17d2:	a0 82       	st	Z, r10
    17d4:	0f b6       	in	r0, 0x3f	; 63
    17d6:	f8 94       	cli
    17d8:	0f 92       	push	r0
    17da:	80 91 ef 04 	lds	r24, 0x04EF	; 0x8004ef <uxCurrentNumberOfTasks>
    17de:	8f 5f       	subi	r24, 0xFF	; 255
    17e0:	80 93 ef 04 	sts	0x04EF, r24	; 0x8004ef <uxCurrentNumberOfTasks>
    17e4:	80 91 46 05 	lds	r24, 0x0546	; 0x800546 <pxCurrentTCB>
    17e8:	90 91 47 05 	lds	r25, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    17ec:	89 2b       	or	r24, r25
    17ee:	59 f4       	brne	.+22     	; 0x1806 <xTaskGenericCreate+0xba>
    17f0:	b0 92 47 05 	sts	0x0547, r11	; 0x800547 <pxCurrentTCB+0x1>
    17f4:	a0 92 46 05 	sts	0x0546, r10	; 0x800546 <pxCurrentTCB>
    17f8:	80 91 ef 04 	lds	r24, 0x04EF	; 0x8004ef <uxCurrentNumberOfTasks>
    17fc:	81 30       	cpi	r24, 0x01	; 1
    17fe:	91 f4       	brne	.+36     	; 0x1824 <xTaskGenericCreate+0xd8>
    1800:	0e 94 3c 0b 	call	0x1678	; 0x1678 <prvInitialiseTaskLists>
    1804:	0f c0       	rjmp	.+30     	; 0x1824 <xTaskGenericCreate+0xd8>
    1806:	80 91 ea 04 	lds	r24, 0x04EA	; 0x8004ea <xSchedulerRunning>
    180a:	81 11       	cpse	r24, r1
    180c:	0b c0       	rjmp	.+22     	; 0x1824 <xTaskGenericCreate+0xd8>
    180e:	e0 91 46 05 	lds	r30, 0x0546	; 0x800546 <pxCurrentTCB>
    1812:	f0 91 47 05 	lds	r31, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1816:	86 89       	ldd	r24, Z+22	; 0x16
    1818:	78 16       	cp	r7, r24
    181a:	20 f0       	brcs	.+8      	; 0x1824 <xTaskGenericCreate+0xd8>
    181c:	b0 92 47 05 	sts	0x0547, r11	; 0x800547 <pxCurrentTCB+0x1>
    1820:	a0 92 46 05 	sts	0x0546, r10	; 0x800546 <pxCurrentTCB>
    1824:	f5 01       	movw	r30, r10
    1826:	86 89       	ldd	r24, Z+22	; 0x16
    1828:	90 91 ec 04 	lds	r25, 0x04EC	; 0x8004ec <uxTopUsedPriority>
    182c:	98 17       	cp	r25, r24
    182e:	10 f4       	brcc	.+4      	; 0x1834 <xTaskGenericCreate+0xe8>
    1830:	80 93 ec 04 	sts	0x04EC, r24	; 0x8004ec <uxTopUsedPriority>
    1834:	90 91 e5 04 	lds	r25, 0x04E5	; 0x8004e5 <uxTaskNumber>
    1838:	9f 5f       	subi	r25, 0xFF	; 255
    183a:	90 93 e5 04 	sts	0x04E5, r25	; 0x8004e5 <uxTaskNumber>
    183e:	90 91 eb 04 	lds	r25, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1842:	98 17       	cp	r25, r24
    1844:	10 f4       	brcc	.+4      	; 0x184a <xTaskGenericCreate+0xfe>
    1846:	80 93 eb 04 	sts	0x04EB, r24	; 0x8004eb <uxTopReadyPriority>
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	b5 01       	movw	r22, r10
    184e:	6e 5f       	subi	r22, 0xFE	; 254
    1850:	7f 4f       	sbci	r23, 0xFF	; 255
    1852:	9c 01       	movw	r18, r24
    1854:	22 0f       	add	r18, r18
    1856:	33 1f       	adc	r19, r19
    1858:	22 0f       	add	r18, r18
    185a:	33 1f       	adc	r19, r19
    185c:	22 0f       	add	r18, r18
    185e:	33 1f       	adc	r19, r19
    1860:	82 0f       	add	r24, r18
    1862:	93 1f       	adc	r25, r19
    1864:	87 5e       	subi	r24, 0xE7	; 231
    1866:	9a 4f       	sbci	r25, 0xFA	; 250
    1868:	0e 94 08 07 	call	0xe10	; 0xe10 <vListInsertEnd>
    186c:	0f 90       	pop	r0
    186e:	0f be       	out	0x3f, r0	; 63
    1870:	f1 e0       	ldi	r31, 0x01	; 1
    1872:	f9 83       	std	Y+1, r31	; 0x01
    1874:	02 c0       	rjmp	.+4      	; 0x187a <xTaskGenericCreate+0x12e>
    1876:	8f ef       	ldi	r24, 0xFF	; 255
    1878:	89 83       	std	Y+1, r24	; 0x01
    187a:	e9 81       	ldd	r30, Y+1	; 0x01
    187c:	e1 30       	cpi	r30, 0x01	; 1
    187e:	69 f4       	brne	.+26     	; 0x189a <xTaskGenericCreate+0x14e>
    1880:	80 91 ea 04 	lds	r24, 0x04EA	; 0x8004ea <xSchedulerRunning>
    1884:	88 23       	and	r24, r24
    1886:	49 f0       	breq	.+18     	; 0x189a <xTaskGenericCreate+0x14e>
    1888:	e0 91 46 05 	lds	r30, 0x0546	; 0x800546 <pxCurrentTCB>
    188c:	f0 91 47 05 	lds	r31, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1890:	86 89       	ldd	r24, Z+22	; 0x16
    1892:	87 15       	cp	r24, r7
    1894:	10 f4       	brcc	.+4      	; 0x189a <xTaskGenericCreate+0x14e>
    1896:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
    189a:	89 81       	ldd	r24, Y+1	; 0x01
    189c:	0f 90       	pop	r0
    189e:	0f 90       	pop	r0
    18a0:	0f 90       	pop	r0
    18a2:	0f 90       	pop	r0
    18a4:	df 91       	pop	r29
    18a6:	cf 91       	pop	r28
    18a8:	1f 91       	pop	r17
    18aa:	0f 91       	pop	r16
    18ac:	ff 90       	pop	r15
    18ae:	ef 90       	pop	r14
    18b0:	df 90       	pop	r13
    18b2:	cf 90       	pop	r12
    18b4:	bf 90       	pop	r11
    18b6:	af 90       	pop	r10
    18b8:	9f 90       	pop	r9
    18ba:	8f 90       	pop	r8
    18bc:	7f 90       	pop	r7
    18be:	5f 90       	pop	r5
    18c0:	4f 90       	pop	r4
    18c2:	3f 90       	pop	r3
    18c4:	2f 90       	pop	r2
    18c6:	08 95       	ret

000018c8 <vTaskDelete>:
    18c8:	ef 92       	push	r14
    18ca:	ff 92       	push	r15
    18cc:	0f 93       	push	r16
    18ce:	1f 93       	push	r17
    18d0:	cf 93       	push	r28
    18d2:	df 93       	push	r29
    18d4:	ec 01       	movw	r28, r24
    18d6:	0f b6       	in	r0, 0x3f	; 63
    18d8:	f8 94       	cli
    18da:	0f 92       	push	r0
    18dc:	80 91 46 05 	lds	r24, 0x0546	; 0x800546 <pxCurrentTCB>
    18e0:	90 91 47 05 	lds	r25, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    18e4:	8c 17       	cp	r24, r28
    18e6:	9d 07       	cpc	r25, r29
    18e8:	11 f4       	brne	.+4      	; 0x18ee <vTaskDelete+0x26>
    18ea:	c0 e0       	ldi	r28, 0x00	; 0
    18ec:	d0 e0       	ldi	r29, 0x00	; 0
    18ee:	20 97       	sbiw	r28, 0x00	; 0
    18f0:	29 f4       	brne	.+10     	; 0x18fc <vTaskDelete+0x34>
    18f2:	00 91 46 05 	lds	r16, 0x0546	; 0x800546 <pxCurrentTCB>
    18f6:	10 91 47 05 	lds	r17, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    18fa:	01 c0       	rjmp	.+2      	; 0x18fe <vTaskDelete+0x36>
    18fc:	8e 01       	movw	r16, r28
    18fe:	78 01       	movw	r14, r16
    1900:	82 e0       	ldi	r24, 0x02	; 2
    1902:	e8 0e       	add	r14, r24
    1904:	f1 1c       	adc	r15, r1
    1906:	c7 01       	movw	r24, r14
    1908:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
    190c:	f8 01       	movw	r30, r16
    190e:	84 89       	ldd	r24, Z+20	; 0x14
    1910:	95 89       	ldd	r25, Z+21	; 0x15
    1912:	89 2b       	or	r24, r25
    1914:	21 f0       	breq	.+8      	; 0x191e <vTaskDelete+0x56>
    1916:	c8 01       	movw	r24, r16
    1918:	0c 96       	adiw	r24, 0x0c	; 12
    191a:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
    191e:	b7 01       	movw	r22, r14
    1920:	81 ef       	ldi	r24, 0xF1	; 241
    1922:	94 e0       	ldi	r25, 0x04	; 4
    1924:	0e 94 08 07 	call	0xe10	; 0xe10 <vListInsertEnd>
    1928:	80 91 f0 04 	lds	r24, 0x04F0	; 0x8004f0 <uxTasksDeleted>
    192c:	8f 5f       	subi	r24, 0xFF	; 255
    192e:	80 93 f0 04 	sts	0x04F0, r24	; 0x8004f0 <uxTasksDeleted>
    1932:	80 91 e5 04 	lds	r24, 0x04E5	; 0x8004e5 <uxTaskNumber>
    1936:	8f 5f       	subi	r24, 0xFF	; 255
    1938:	80 93 e5 04 	sts	0x04E5, r24	; 0x8004e5 <uxTaskNumber>
    193c:	0f 90       	pop	r0
    193e:	0f be       	out	0x3f, r0	; 63
    1940:	80 91 ea 04 	lds	r24, 0x04EA	; 0x8004ea <xSchedulerRunning>
    1944:	88 23       	and	r24, r24
    1946:	21 f0       	breq	.+8      	; 0x1950 <vTaskDelete+0x88>
    1948:	cd 2b       	or	r28, r29
    194a:	11 f4       	brne	.+4      	; 0x1950 <vTaskDelete+0x88>
    194c:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	1f 91       	pop	r17
    1956:	0f 91       	pop	r16
    1958:	ff 90       	pop	r15
    195a:	ef 90       	pop	r14
    195c:	08 95       	ret

0000195e <vTaskStartScheduler>:
    195e:	af 92       	push	r10
    1960:	bf 92       	push	r11
    1962:	cf 92       	push	r12
    1964:	df 92       	push	r13
    1966:	ef 92       	push	r14
    1968:	ff 92       	push	r15
    196a:	0f 93       	push	r16
    196c:	a1 2c       	mov	r10, r1
    196e:	b1 2c       	mov	r11, r1
    1970:	c1 2c       	mov	r12, r1
    1972:	d1 2c       	mov	r13, r1
    1974:	e1 2c       	mov	r14, r1
    1976:	f1 2c       	mov	r15, r1
    1978:	00 e0       	ldi	r16, 0x00	; 0
    197a:	20 e0       	ldi	r18, 0x00	; 0
    197c:	30 e0       	ldi	r19, 0x00	; 0
    197e:	45 e5       	ldi	r20, 0x55	; 85
    1980:	50 e0       	ldi	r21, 0x00	; 0
    1982:	64 ed       	ldi	r22, 0xD4	; 212
    1984:	70 e0       	ldi	r23, 0x00	; 0
    1986:	8d e4       	ldi	r24, 0x4D	; 77
    1988:	9e e0       	ldi	r25, 0x0E	; 14
    198a:	0e 94 a6 0b 	call	0x174c	; 0x174c <xTaskGenericCreate>
    198e:	81 30       	cpi	r24, 0x01	; 1
    1990:	49 f4       	brne	.+18     	; 0x19a4 <vTaskStartScheduler+0x46>
    1992:	f8 94       	cli
    1994:	80 93 ea 04 	sts	0x04EA, r24	; 0x8004ea <xSchedulerRunning>
    1998:	10 92 ee 04 	sts	0x04EE, r1	; 0x8004ee <xTickCount+0x1>
    199c:	10 92 ed 04 	sts	0x04ED, r1	; 0x8004ed <xTickCount>
    19a0:	0e 94 fb 07 	call	0xff6	; 0xff6 <xPortStartScheduler>
    19a4:	0f 91       	pop	r16
    19a6:	ff 90       	pop	r15
    19a8:	ef 90       	pop	r14
    19aa:	df 90       	pop	r13
    19ac:	cf 90       	pop	r12
    19ae:	bf 90       	pop	r11
    19b0:	af 90       	pop	r10
    19b2:	08 95       	ret

000019b4 <vTaskSuspendAll>:
    19b4:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <uxSchedulerSuspended>
    19b8:	8f 5f       	subi	r24, 0xFF	; 255
    19ba:	80 93 e9 04 	sts	0x04E9, r24	; 0x8004e9 <uxSchedulerSuspended>
    19be:	08 95       	ret

000019c0 <vTaskIncrementTick>:
    19c0:	0f 93       	push	r16
    19c2:	1f 93       	push	r17
    19c4:	cf 93       	push	r28
    19c6:	df 93       	push	r29
    19c8:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <uxSchedulerSuspended>
    19cc:	81 11       	cpse	r24, r1
    19ce:	98 c0       	rjmp	.+304    	; 0x1b00 <vTaskIncrementTick+0x140>
    19d0:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <xTickCount>
    19d4:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <xTickCount+0x1>
    19d8:	01 96       	adiw	r24, 0x01	; 1
    19da:	90 93 ee 04 	sts	0x04EE, r25	; 0x8004ee <xTickCount+0x1>
    19de:	80 93 ed 04 	sts	0x04ED, r24	; 0x8004ed <xTickCount>
    19e2:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <xTickCount>
    19e6:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <xTickCount+0x1>
    19ea:	89 2b       	or	r24, r25
    19ec:	99 f5       	brne	.+102    	; 0x1a54 <vTaskIncrementTick+0x94>
    19ee:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <pxDelayedTaskList>
    19f2:	90 91 06 05 	lds	r25, 0x0506	; 0x800506 <pxDelayedTaskList+0x1>
    19f6:	20 91 03 05 	lds	r18, 0x0503	; 0x800503 <pxOverflowDelayedTaskList>
    19fa:	30 91 04 05 	lds	r19, 0x0504	; 0x800504 <pxOverflowDelayedTaskList+0x1>
    19fe:	30 93 06 05 	sts	0x0506, r19	; 0x800506 <pxDelayedTaskList+0x1>
    1a02:	20 93 05 05 	sts	0x0505, r18	; 0x800505 <pxDelayedTaskList>
    1a06:	90 93 04 05 	sts	0x0504, r25	; 0x800504 <pxOverflowDelayedTaskList+0x1>
    1a0a:	80 93 03 05 	sts	0x0503, r24	; 0x800503 <pxOverflowDelayedTaskList>
    1a0e:	80 91 e6 04 	lds	r24, 0x04E6	; 0x8004e6 <xNumOfOverflows>
    1a12:	8f 5f       	subi	r24, 0xFF	; 255
    1a14:	80 93 e6 04 	sts	0x04E6, r24	; 0x8004e6 <xNumOfOverflows>
    1a18:	e0 91 05 05 	lds	r30, 0x0505	; 0x800505 <pxDelayedTaskList>
    1a1c:	f0 91 06 05 	lds	r31, 0x0506	; 0x800506 <pxDelayedTaskList+0x1>
    1a20:	80 81       	ld	r24, Z
    1a22:	81 11       	cpse	r24, r1
    1a24:	07 c0       	rjmp	.+14     	; 0x1a34 <vTaskIncrementTick+0x74>
    1a26:	8f ef       	ldi	r24, 0xFF	; 255
    1a28:	9f ef       	ldi	r25, 0xFF	; 255
    1a2a:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <xNextTaskUnblockTime+0x1>
    1a2e:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <xNextTaskUnblockTime>
    1a32:	10 c0       	rjmp	.+32     	; 0x1a54 <vTaskIncrementTick+0x94>
    1a34:	e0 91 05 05 	lds	r30, 0x0505	; 0x800505 <pxDelayedTaskList>
    1a38:	f0 91 06 05 	lds	r31, 0x0506	; 0x800506 <pxDelayedTaskList+0x1>
    1a3c:	05 80       	ldd	r0, Z+5	; 0x05
    1a3e:	f6 81       	ldd	r31, Z+6	; 0x06
    1a40:	e0 2d       	mov	r30, r0
    1a42:	06 80       	ldd	r0, Z+6	; 0x06
    1a44:	f7 81       	ldd	r31, Z+7	; 0x07
    1a46:	e0 2d       	mov	r30, r0
    1a48:	82 81       	ldd	r24, Z+2	; 0x02
    1a4a:	93 81       	ldd	r25, Z+3	; 0x03
    1a4c:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <xNextTaskUnblockTime+0x1>
    1a50:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <xNextTaskUnblockTime>
    1a54:	20 91 ed 04 	lds	r18, 0x04ED	; 0x8004ed <xTickCount>
    1a58:	30 91 ee 04 	lds	r19, 0x04EE	; 0x8004ee <xTickCount+0x1>
    1a5c:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <xNextTaskUnblockTime>
    1a60:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <xNextTaskUnblockTime+0x1>
    1a64:	28 17       	cp	r18, r24
    1a66:	39 07       	cpc	r19, r25
    1a68:	08 f4       	brcc	.+2      	; 0x1a6c <vTaskIncrementTick+0xac>
    1a6a:	4f c0       	rjmp	.+158    	; 0x1b0a <vTaskIncrementTick+0x14a>
    1a6c:	e0 91 05 05 	lds	r30, 0x0505	; 0x800505 <pxDelayedTaskList>
    1a70:	f0 91 06 05 	lds	r31, 0x0506	; 0x800506 <pxDelayedTaskList+0x1>
    1a74:	80 81       	ld	r24, Z
    1a76:	81 11       	cpse	r24, r1
    1a78:	07 c0       	rjmp	.+14     	; 0x1a88 <vTaskIncrementTick+0xc8>
    1a7a:	8f ef       	ldi	r24, 0xFF	; 255
    1a7c:	9f ef       	ldi	r25, 0xFF	; 255
    1a7e:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <xNextTaskUnblockTime+0x1>
    1a82:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <xNextTaskUnblockTime>
    1a86:	41 c0       	rjmp	.+130    	; 0x1b0a <vTaskIncrementTick+0x14a>
    1a88:	e0 91 05 05 	lds	r30, 0x0505	; 0x800505 <pxDelayedTaskList>
    1a8c:	f0 91 06 05 	lds	r31, 0x0506	; 0x800506 <pxDelayedTaskList+0x1>
    1a90:	05 80       	ldd	r0, Z+5	; 0x05
    1a92:	f6 81       	ldd	r31, Z+6	; 0x06
    1a94:	e0 2d       	mov	r30, r0
    1a96:	c6 81       	ldd	r28, Z+6	; 0x06
    1a98:	d7 81       	ldd	r29, Z+7	; 0x07
    1a9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a9c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a9e:	20 91 ed 04 	lds	r18, 0x04ED	; 0x8004ed <xTickCount>
    1aa2:	30 91 ee 04 	lds	r19, 0x04EE	; 0x8004ee <xTickCount+0x1>
    1aa6:	28 17       	cp	r18, r24
    1aa8:	39 07       	cpc	r19, r25
    1aaa:	28 f4       	brcc	.+10     	; 0x1ab6 <vTaskIncrementTick+0xf6>
    1aac:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <xNextTaskUnblockTime+0x1>
    1ab0:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <xNextTaskUnblockTime>
    1ab4:	2a c0       	rjmp	.+84     	; 0x1b0a <vTaskIncrementTick+0x14a>
    1ab6:	8e 01       	movw	r16, r28
    1ab8:	0e 5f       	subi	r16, 0xFE	; 254
    1aba:	1f 4f       	sbci	r17, 0xFF	; 255
    1abc:	c8 01       	movw	r24, r16
    1abe:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
    1ac2:	8c 89       	ldd	r24, Y+20	; 0x14
    1ac4:	9d 89       	ldd	r25, Y+21	; 0x15
    1ac6:	89 2b       	or	r24, r25
    1ac8:	21 f0       	breq	.+8      	; 0x1ad2 <vTaskIncrementTick+0x112>
    1aca:	ce 01       	movw	r24, r28
    1acc:	0c 96       	adiw	r24, 0x0c	; 12
    1ace:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
    1ad2:	8e 89       	ldd	r24, Y+22	; 0x16
    1ad4:	90 91 eb 04 	lds	r25, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1ad8:	98 17       	cp	r25, r24
    1ada:	10 f4       	brcc	.+4      	; 0x1ae0 <vTaskIncrementTick+0x120>
    1adc:	80 93 eb 04 	sts	0x04EB, r24	; 0x8004eb <uxTopReadyPriority>
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
    1ae2:	9c 01       	movw	r18, r24
    1ae4:	22 0f       	add	r18, r18
    1ae6:	33 1f       	adc	r19, r19
    1ae8:	22 0f       	add	r18, r18
    1aea:	33 1f       	adc	r19, r19
    1aec:	22 0f       	add	r18, r18
    1aee:	33 1f       	adc	r19, r19
    1af0:	82 0f       	add	r24, r18
    1af2:	93 1f       	adc	r25, r19
    1af4:	b8 01       	movw	r22, r16
    1af6:	87 5e       	subi	r24, 0xE7	; 231
    1af8:	9a 4f       	sbci	r25, 0xFA	; 250
    1afa:	0e 94 08 07 	call	0xe10	; 0xe10 <vListInsertEnd>
    1afe:	b6 cf       	rjmp	.-148    	; 0x1a6c <vTaskIncrementTick+0xac>
    1b00:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <uxMissedTicks>
    1b04:	8f 5f       	subi	r24, 0xFF	; 255
    1b06:	80 93 e8 04 	sts	0x04E8, r24	; 0x8004e8 <uxMissedTicks>
    1b0a:	df 91       	pop	r29
    1b0c:	cf 91       	pop	r28
    1b0e:	1f 91       	pop	r17
    1b10:	0f 91       	pop	r16
    1b12:	08 95       	ret

00001b14 <xTaskResumeAll>:
    1b14:	ff 92       	push	r15
    1b16:	0f 93       	push	r16
    1b18:	1f 93       	push	r17
    1b1a:	cf 93       	push	r28
    1b1c:	df 93       	push	r29
    1b1e:	0f b6       	in	r0, 0x3f	; 63
    1b20:	f8 94       	cli
    1b22:	0f 92       	push	r0
    1b24:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <uxSchedulerSuspended>
    1b28:	81 50       	subi	r24, 0x01	; 1
    1b2a:	80 93 e9 04 	sts	0x04E9, r24	; 0x8004e9 <uxSchedulerSuspended>
    1b2e:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <uxSchedulerSuspended>
    1b32:	81 11       	cpse	r24, r1
    1b34:	58 c0       	rjmp	.+176    	; 0x1be6 <xTaskResumeAll+0xd2>
    1b36:	80 91 ef 04 	lds	r24, 0x04EF	; 0x8004ef <uxCurrentNumberOfTasks>
    1b3a:	81 11       	cpse	r24, r1
    1b3c:	32 c0       	rjmp	.+100    	; 0x1ba2 <xTaskResumeAll+0x8e>
    1b3e:	56 c0       	rjmp	.+172    	; 0x1bec <xTaskResumeAll+0xd8>
    1b40:	e0 91 ff 04 	lds	r30, 0x04FF	; 0x8004ff <xPendingReadyList+0x5>
    1b44:	f0 91 00 05 	lds	r31, 0x0500	; 0x800500 <xPendingReadyList+0x6>
    1b48:	c6 81       	ldd	r28, Z+6	; 0x06
    1b4a:	d7 81       	ldd	r29, Z+7	; 0x07
    1b4c:	ce 01       	movw	r24, r28
    1b4e:	0c 96       	adiw	r24, 0x0c	; 12
    1b50:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
    1b54:	8e 01       	movw	r16, r28
    1b56:	0e 5f       	subi	r16, 0xFE	; 254
    1b58:	1f 4f       	sbci	r17, 0xFF	; 255
    1b5a:	c8 01       	movw	r24, r16
    1b5c:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
    1b60:	8e 89       	ldd	r24, Y+22	; 0x16
    1b62:	90 91 eb 04 	lds	r25, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1b66:	98 17       	cp	r25, r24
    1b68:	10 f4       	brcc	.+4      	; 0x1b6e <xTaskResumeAll+0x5a>
    1b6a:	80 93 eb 04 	sts	0x04EB, r24	; 0x8004eb <uxTopReadyPriority>
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	9c 01       	movw	r18, r24
    1b72:	22 0f       	add	r18, r18
    1b74:	33 1f       	adc	r19, r19
    1b76:	22 0f       	add	r18, r18
    1b78:	33 1f       	adc	r19, r19
    1b7a:	22 0f       	add	r18, r18
    1b7c:	33 1f       	adc	r19, r19
    1b7e:	82 0f       	add	r24, r18
    1b80:	93 1f       	adc	r25, r19
    1b82:	b8 01       	movw	r22, r16
    1b84:	87 5e       	subi	r24, 0xE7	; 231
    1b86:	9a 4f       	sbci	r25, 0xFA	; 250
    1b88:	0e 94 08 07 	call	0xe10	; 0xe10 <vListInsertEnd>
    1b8c:	9e 89       	ldd	r25, Y+22	; 0x16
    1b8e:	e0 91 46 05 	lds	r30, 0x0546	; 0x800546 <pxCurrentTCB>
    1b92:	f0 91 47 05 	lds	r31, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1b96:	86 89       	ldd	r24, Z+22	; 0x16
    1b98:	98 17       	cp	r25, r24
    1b9a:	20 f0       	brcs	.+8      	; 0x1ba4 <xTaskResumeAll+0x90>
    1b9c:	ff 24       	eor	r15, r15
    1b9e:	f3 94       	inc	r15
    1ba0:	01 c0       	rjmp	.+2      	; 0x1ba4 <xTaskResumeAll+0x90>
    1ba2:	f1 2c       	mov	r15, r1
    1ba4:	80 91 fa 04 	lds	r24, 0x04FA	; 0x8004fa <xPendingReadyList>
    1ba8:	81 11       	cpse	r24, r1
    1baa:	ca cf       	rjmp	.-108    	; 0x1b40 <xTaskResumeAll+0x2c>
    1bac:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <uxMissedTicks>
    1bb0:	81 11       	cpse	r24, r1
    1bb2:	08 c0       	rjmp	.+16     	; 0x1bc4 <xTaskResumeAll+0xb0>
    1bb4:	0b c0       	rjmp	.+22     	; 0x1bcc <xTaskResumeAll+0xb8>
    1bb6:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <vTaskIncrementTick>
    1bba:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <uxMissedTicks>
    1bbe:	81 50       	subi	r24, 0x01	; 1
    1bc0:	80 93 e8 04 	sts	0x04E8, r24	; 0x8004e8 <uxMissedTicks>
    1bc4:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <uxMissedTicks>
    1bc8:	81 11       	cpse	r24, r1
    1bca:	f5 cf       	rjmp	.-22     	; 0x1bb6 <xTaskResumeAll+0xa2>
    1bcc:	81 e0       	ldi	r24, 0x01	; 1
    1bce:	f8 16       	cp	r15, r24
    1bd0:	21 f0       	breq	.+8      	; 0x1bda <xTaskResumeAll+0xc6>
    1bd2:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <xMissedYield>
    1bd6:	81 30       	cpi	r24, 0x01	; 1
    1bd8:	41 f4       	brne	.+16     	; 0x1bea <xTaskResumeAll+0xd6>
    1bda:	10 92 e7 04 	sts	0x04E7, r1	; 0x8004e7 <xMissedYield>
    1bde:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
    1be2:	81 e0       	ldi	r24, 0x01	; 1
    1be4:	03 c0       	rjmp	.+6      	; 0x1bec <xTaskResumeAll+0xd8>
    1be6:	80 e0       	ldi	r24, 0x00	; 0
    1be8:	01 c0       	rjmp	.+2      	; 0x1bec <xTaskResumeAll+0xd8>
    1bea:	80 e0       	ldi	r24, 0x00	; 0
    1bec:	0f 90       	pop	r0
    1bee:	0f be       	out	0x3f, r0	; 63
    1bf0:	df 91       	pop	r29
    1bf2:	cf 91       	pop	r28
    1bf4:	1f 91       	pop	r17
    1bf6:	0f 91       	pop	r16
    1bf8:	ff 90       	pop	r15
    1bfa:	08 95       	ret

00001bfc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1bfc:	cf 93       	push	r28
    1bfe:	df 93       	push	r29
    1c00:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1c02:	89 2b       	or	r24, r25
    1c04:	a9 f0       	breq	.+42     	; 0x1c30 <vTaskDelay+0x34>
		{
			vTaskSuspendAll();
    1c06:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1c0a:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <xTickCount>
    1c0e:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <xTickCount+0x1>
    1c12:	c8 0f       	add	r28, r24
    1c14:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c16:	80 91 46 05 	lds	r24, 0x0546	; 0x800546 <pxCurrentTCB>
    1c1a:	90 91 47 05 	lds	r25, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1c1e:	02 96       	adiw	r24, 0x02	; 2
    1c20:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c24:	ce 01       	movw	r24, r28
    1c26:	0e 94 6f 0b 	call	0x16de	; 0x16de <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1c2a:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>
    1c2e:	01 c0       	rjmp	.+2      	; 0x1c32 <vTaskDelay+0x36>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1c30:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c32:	81 11       	cpse	r24, r1
    1c34:	02 c0       	rjmp	.+4      	; 0x1c3a <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    1c36:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
		}
	}
    1c3a:	df 91       	pop	r29
    1c3c:	cf 91       	pop	r28
    1c3e:	08 95       	ret

00001c40 <prvCheckTasksWaitingTermination>:
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1c40:	cf 93       	push	r28
    1c42:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1c44:	80 91 f0 04 	lds	r24, 0x04F0	; 0x8004f0 <uxTasksDeleted>
    1c48:	88 23       	and	r24, r24
    1c4a:	21 f1       	breq	.+72     	; 0x1c94 <prvCheckTasksWaitingTermination+0x54>
		{
			vTaskSuspendAll();
    1c4c:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1c50:	c0 91 f1 04 	lds	r28, 0x04F1	; 0x8004f1 <xTasksWaitingTermination>
			xTaskResumeAll();
    1c54:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1c58:	cc 23       	and	r28, r28
    1c5a:	e1 f0       	breq	.+56     	; 0x1c94 <prvCheckTasksWaitingTermination+0x54>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1c5c:	0f b6       	in	r0, 0x3f	; 63
    1c5e:	f8 94       	cli
    1c60:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1c62:	e0 91 f6 04 	lds	r30, 0x04F6	; 0x8004f6 <xTasksWaitingTermination+0x5>
    1c66:	f0 91 f7 04 	lds	r31, 0x04F7	; 0x8004f7 <xTasksWaitingTermination+0x6>
    1c6a:	c6 81       	ldd	r28, Z+6	; 0x06
    1c6c:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1c6e:	ce 01       	movw	r24, r28
    1c70:	02 96       	adiw	r24, 0x02	; 2
    1c72:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
					--uxCurrentNumberOfTasks;
    1c76:	80 91 ef 04 	lds	r24, 0x04EF	; 0x8004ef <uxCurrentNumberOfTasks>
    1c7a:	81 50       	subi	r24, 0x01	; 1
    1c7c:	80 93 ef 04 	sts	0x04EF, r24	; 0x8004ef <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    1c80:	80 91 f0 04 	lds	r24, 0x04F0	; 0x8004f0 <uxTasksDeleted>
    1c84:	81 50       	subi	r24, 0x01	; 1
    1c86:	80 93 f0 04 	sts	0x04F0, r24	; 0x8004f0 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1c8a:	0f 90       	pop	r0
    1c8c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    1c8e:	ce 01       	movw	r24, r28
    1c90:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    1c94:	df 91       	pop	r29
    1c96:	cf 91       	pop	r28
    1c98:	08 95       	ret

00001c9a <prvIdleTask>:
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    1c9a:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    1c9e:	0e 94 2a 08 	call	0x1054	; 0x1054 <vPortYield>
    1ca2:	fb cf       	rjmp	.-10     	; 0x1c9a <prvIdleTask>

00001ca4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1ca4:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <uxSchedulerSuspended>
    1ca8:	88 23       	and	r24, r24
    1caa:	49 f0       	breq	.+18     	; 0x1cbe <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1cac:	81 e0       	ldi	r24, 0x01	; 1
    1cae:	80 93 e7 04 	sts	0x04E7, r24	; 0x8004e7 <xMissedYield>
    1cb2:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1cb4:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1cb8:	81 50       	subi	r24, 0x01	; 1
    1cba:	80 93 eb 04 	sts	0x04EB, r24	; 0x8004eb <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1cbe:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
    1cc4:	fc 01       	movw	r30, r24
    1cc6:	ee 0f       	add	r30, r30
    1cc8:	ff 1f       	adc	r31, r31
    1cca:	ee 0f       	add	r30, r30
    1ccc:	ff 1f       	adc	r31, r31
    1cce:	ee 0f       	add	r30, r30
    1cd0:	ff 1f       	adc	r31, r31
    1cd2:	8e 0f       	add	r24, r30
    1cd4:	9f 1f       	adc	r25, r31
    1cd6:	fc 01       	movw	r30, r24
    1cd8:	e7 5e       	subi	r30, 0xE7	; 231
    1cda:	fa 4f       	sbci	r31, 0xFA	; 250
    1cdc:	80 81       	ld	r24, Z
    1cde:	88 23       	and	r24, r24
    1ce0:	49 f3       	breq	.-46     	; 0x1cb4 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1ce2:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	9c 01       	movw	r18, r24
    1cea:	22 0f       	add	r18, r18
    1cec:	33 1f       	adc	r19, r19
    1cee:	22 0f       	add	r18, r18
    1cf0:	33 1f       	adc	r19, r19
    1cf2:	22 0f       	add	r18, r18
    1cf4:	33 1f       	adc	r19, r19
    1cf6:	28 0f       	add	r18, r24
    1cf8:	39 1f       	adc	r19, r25
    1cfa:	d9 01       	movw	r26, r18
    1cfc:	a7 5e       	subi	r26, 0xE7	; 231
    1cfe:	ba 4f       	sbci	r27, 0xFA	; 250
    1d00:	11 96       	adiw	r26, 0x01	; 1
    1d02:	ed 91       	ld	r30, X+
    1d04:	fc 91       	ld	r31, X
    1d06:	12 97       	sbiw	r26, 0x02	; 2
    1d08:	02 80       	ldd	r0, Z+2	; 0x02
    1d0a:	f3 81       	ldd	r31, Z+3	; 0x03
    1d0c:	e0 2d       	mov	r30, r0
    1d0e:	12 96       	adiw	r26, 0x02	; 2
    1d10:	fc 93       	st	X, r31
    1d12:	ee 93       	st	-X, r30
    1d14:	11 97       	sbiw	r26, 0x01	; 1
    1d16:	24 5e       	subi	r18, 0xE4	; 228
    1d18:	3a 4f       	sbci	r19, 0xFA	; 250
    1d1a:	e2 17       	cp	r30, r18
    1d1c:	f3 07       	cpc	r31, r19
    1d1e:	29 f4       	brne	.+10     	; 0x1d2a <vTaskSwitchContext+0x86>
    1d20:	22 81       	ldd	r18, Z+2	; 0x02
    1d22:	33 81       	ldd	r19, Z+3	; 0x03
    1d24:	fd 01       	movw	r30, r26
    1d26:	32 83       	std	Z+2, r19	; 0x02
    1d28:	21 83       	std	Z+1, r18	; 0x01
    1d2a:	fc 01       	movw	r30, r24
    1d2c:	ee 0f       	add	r30, r30
    1d2e:	ff 1f       	adc	r31, r31
    1d30:	ee 0f       	add	r30, r30
    1d32:	ff 1f       	adc	r31, r31
    1d34:	ee 0f       	add	r30, r30
    1d36:	ff 1f       	adc	r31, r31
    1d38:	8e 0f       	add	r24, r30
    1d3a:	9f 1f       	adc	r25, r31
    1d3c:	fc 01       	movw	r30, r24
    1d3e:	e7 5e       	subi	r30, 0xE7	; 231
    1d40:	fa 4f       	sbci	r31, 0xFA	; 250
    1d42:	01 80       	ldd	r0, Z+1	; 0x01
    1d44:	f2 81       	ldd	r31, Z+2	; 0x02
    1d46:	e0 2d       	mov	r30, r0
    1d48:	86 81       	ldd	r24, Z+6	; 0x06
    1d4a:	97 81       	ldd	r25, Z+7	; 0x07
    1d4c:	90 93 47 05 	sts	0x0547, r25	; 0x800547 <pxCurrentTCB+0x1>
    1d50:	80 93 46 05 	sts	0x0546, r24	; 0x800546 <pxCurrentTCB>
    1d54:	08 95       	ret

00001d56 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1d56:	cf 93       	push	r28
    1d58:	df 93       	push	r29
    1d5a:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1d5c:	60 91 46 05 	lds	r22, 0x0546	; 0x800546 <pxCurrentTCB>
    1d60:	70 91 47 05 	lds	r23, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1d64:	64 5f       	subi	r22, 0xF4	; 244
    1d66:	7f 4f       	sbci	r23, 0xFF	; 255
    1d68:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d6c:	80 91 46 05 	lds	r24, 0x0546	; 0x800546 <pxCurrentTCB>
    1d70:	90 91 47 05 	lds	r25, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1d74:	02 96       	adiw	r24, 0x02	; 2
    1d76:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1d7a:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <xTickCount>
    1d7e:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d82:	8c 0f       	add	r24, r28
    1d84:	9d 1f       	adc	r25, r29
    1d86:	0e 94 6f 0b 	call	0x16de	; 0x16de <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1d8a:	df 91       	pop	r29
    1d8c:	cf 91       	pop	r28
    1d8e:	08 95       	ret

00001d90 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1d90:	0f 93       	push	r16
    1d92:	1f 93       	push	r17
    1d94:	cf 93       	push	r28
    1d96:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1d98:	dc 01       	movw	r26, r24
    1d9a:	15 96       	adiw	r26, 0x05	; 5
    1d9c:	ed 91       	ld	r30, X+
    1d9e:	fc 91       	ld	r31, X
    1da0:	16 97       	sbiw	r26, 0x06	; 6
    1da2:	c6 81       	ldd	r28, Z+6	; 0x06
    1da4:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1da6:	8e 01       	movw	r16, r28
    1da8:	04 5f       	subi	r16, 0xF4	; 244
    1daa:	1f 4f       	sbci	r17, 0xFF	; 255
    1dac:	c8 01       	movw	r24, r16
    1dae:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1db2:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <uxSchedulerSuspended>
    1db6:	81 11       	cpse	r24, r1
    1db8:	1c c0       	rjmp	.+56     	; 0x1df2 <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1dba:	0a 50       	subi	r16, 0x0A	; 10
    1dbc:	11 09       	sbc	r17, r1
    1dbe:	c8 01       	movw	r24, r16
    1dc0:	0e 94 60 07 	call	0xec0	; 0xec0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1dc4:	8e 89       	ldd	r24, Y+22	; 0x16
    1dc6:	90 91 eb 04 	lds	r25, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1dca:	98 17       	cp	r25, r24
    1dcc:	10 f4       	brcc	.+4      	; 0x1dd2 <xTaskRemoveFromEventList+0x42>
    1dce:	80 93 eb 04 	sts	0x04EB, r24	; 0x8004eb <uxTopReadyPriority>
    1dd2:	90 e0       	ldi	r25, 0x00	; 0
    1dd4:	9c 01       	movw	r18, r24
    1dd6:	22 0f       	add	r18, r18
    1dd8:	33 1f       	adc	r19, r19
    1dda:	22 0f       	add	r18, r18
    1ddc:	33 1f       	adc	r19, r19
    1dde:	22 0f       	add	r18, r18
    1de0:	33 1f       	adc	r19, r19
    1de2:	82 0f       	add	r24, r18
    1de4:	93 1f       	adc	r25, r19
    1de6:	b8 01       	movw	r22, r16
    1de8:	87 5e       	subi	r24, 0xE7	; 231
    1dea:	9a 4f       	sbci	r25, 0xFA	; 250
    1dec:	0e 94 08 07 	call	0xe10	; 0xe10 <vListInsertEnd>
    1df0:	05 c0       	rjmp	.+10     	; 0x1dfc <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1df2:	b8 01       	movw	r22, r16
    1df4:	8a ef       	ldi	r24, 0xFA	; 250
    1df6:	94 e0       	ldi	r25, 0x04	; 4
    1df8:	0e 94 08 07 	call	0xe10	; 0xe10 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1dfc:	9e 89       	ldd	r25, Y+22	; 0x16
    1dfe:	e0 91 46 05 	lds	r30, 0x0546	; 0x800546 <pxCurrentTCB>
    1e02:	f0 91 47 05 	lds	r31, 0x0547	; 0x800547 <pxCurrentTCB+0x1>
    1e06:	86 89       	ldd	r24, Z+22	; 0x16
    1e08:	98 17       	cp	r25, r24
    1e0a:	10 f0       	brcs	.+4      	; 0x1e10 <xTaskRemoveFromEventList+0x80>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	01 c0       	rjmp	.+2      	; 0x1e12 <xTaskRemoveFromEventList+0x82>
	}
	else
	{
		xReturn = pdFALSE;
    1e10:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    1e12:	df 91       	pop	r29
    1e14:	cf 91       	pop	r28
    1e16:	1f 91       	pop	r17
    1e18:	0f 91       	pop	r16
    1e1a:	08 95       	ret

00001e1c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1e1c:	20 91 e6 04 	lds	r18, 0x04E6	; 0x8004e6 <xNumOfOverflows>
    1e20:	fc 01       	movw	r30, r24
    1e22:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1e24:	20 91 ed 04 	lds	r18, 0x04ED	; 0x8004ed <xTickCount>
    1e28:	30 91 ee 04 	lds	r19, 0x04EE	; 0x8004ee <xTickCount+0x1>
    1e2c:	32 83       	std	Z+2, r19	; 0x02
    1e2e:	21 83       	std	Z+1, r18	; 0x01
    1e30:	08 95       	ret

00001e32 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1e32:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	f8 94       	cli
    1e38:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1e3a:	90 81       	ld	r25, Z
    1e3c:	80 91 e6 04 	lds	r24, 0x04E6	; 0x8004e6 <xNumOfOverflows>
    1e40:	98 17       	cp	r25, r24
    1e42:	49 f0       	breq	.+18     	; 0x1e56 <xTaskCheckForTimeOut+0x24>
    1e44:	21 81       	ldd	r18, Z+1	; 0x01
    1e46:	32 81       	ldd	r19, Z+2	; 0x02
    1e48:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <xTickCount>
    1e4c:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <xTickCount+0x1>
    1e50:	82 17       	cp	r24, r18
    1e52:	93 07       	cpc	r25, r19
    1e54:	f8 f4       	brcc	.+62     	; 0x1e94 <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1e56:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <xTickCount>
    1e5a:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <xTickCount+0x1>
    1e5e:	41 81       	ldd	r20, Z+1	; 0x01
    1e60:	52 81       	ldd	r21, Z+2	; 0x02
    1e62:	84 1b       	sub	r24, r20
    1e64:	95 0b       	sbc	r25, r21
    1e66:	db 01       	movw	r26, r22
    1e68:	2d 91       	ld	r18, X+
    1e6a:	3c 91       	ld	r19, X
    1e6c:	11 97       	sbiw	r26, 0x01	; 1
    1e6e:	82 17       	cp	r24, r18
    1e70:	93 07       	cpc	r25, r19
    1e72:	90 f4       	brcc	.+36     	; 0x1e98 <xTaskCheckForTimeOut+0x66>
    1e74:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1e76:	e0 91 ed 04 	lds	r30, 0x04ED	; 0x8004ed <xTickCount>
    1e7a:	f0 91 ee 04 	lds	r31, 0x04EE	; 0x8004ee <xTickCount+0x1>
    1e7e:	bf 01       	movw	r22, r30
    1e80:	64 1b       	sub	r22, r20
    1e82:	75 0b       	sbc	r23, r21
    1e84:	26 1b       	sub	r18, r22
    1e86:	37 0b       	sbc	r19, r23
    1e88:	2d 93       	st	X+, r18
    1e8a:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1e8c:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1e90:	80 e0       	ldi	r24, 0x00	; 0
    1e92:	03 c0       	rjmp	.+6      	; 0x1e9a <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	01 c0       	rjmp	.+2      	; 0x1e9a <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1e98:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1e9a:	0f 90       	pop	r0
    1e9c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1e9e:	08 95       	ret

00001ea0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	80 93 e7 04 	sts	0x04E7, r24	; 0x8004e7 <xMissedYield>
    1ea6:	08 95       	ret

00001ea8 <__fixunssfsi>:
    1ea8:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <__fp_splitA>
    1eac:	88 f0       	brcs	.+34     	; 0x1ed0 <__fixunssfsi+0x28>
    1eae:	9f 57       	subi	r25, 0x7F	; 127
    1eb0:	98 f0       	brcs	.+38     	; 0x1ed8 <__fixunssfsi+0x30>
    1eb2:	b9 2f       	mov	r27, r25
    1eb4:	99 27       	eor	r25, r25
    1eb6:	b7 51       	subi	r27, 0x17	; 23
    1eb8:	b0 f0       	brcs	.+44     	; 0x1ee6 <__fixunssfsi+0x3e>
    1eba:	e1 f0       	breq	.+56     	; 0x1ef4 <__fixunssfsi+0x4c>
    1ebc:	66 0f       	add	r22, r22
    1ebe:	77 1f       	adc	r23, r23
    1ec0:	88 1f       	adc	r24, r24
    1ec2:	99 1f       	adc	r25, r25
    1ec4:	1a f0       	brmi	.+6      	; 0x1ecc <__fixunssfsi+0x24>
    1ec6:	ba 95       	dec	r27
    1ec8:	c9 f7       	brne	.-14     	; 0x1ebc <__fixunssfsi+0x14>
    1eca:	14 c0       	rjmp	.+40     	; 0x1ef4 <__fixunssfsi+0x4c>
    1ecc:	b1 30       	cpi	r27, 0x01	; 1
    1ece:	91 f0       	breq	.+36     	; 0x1ef4 <__fixunssfsi+0x4c>
    1ed0:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <__fp_zero>
    1ed4:	b1 e0       	ldi	r27, 0x01	; 1
    1ed6:	08 95       	ret
    1ed8:	0c 94 e2 0f 	jmp	0x1fc4	; 0x1fc4 <__fp_zero>
    1edc:	67 2f       	mov	r22, r23
    1ede:	78 2f       	mov	r23, r24
    1ee0:	88 27       	eor	r24, r24
    1ee2:	b8 5f       	subi	r27, 0xF8	; 248
    1ee4:	39 f0       	breq	.+14     	; 0x1ef4 <__fixunssfsi+0x4c>
    1ee6:	b9 3f       	cpi	r27, 0xF9	; 249
    1ee8:	cc f3       	brlt	.-14     	; 0x1edc <__fixunssfsi+0x34>
    1eea:	86 95       	lsr	r24
    1eec:	77 95       	ror	r23
    1eee:	67 95       	ror	r22
    1ef0:	b3 95       	inc	r27
    1ef2:	d9 f7       	brne	.-10     	; 0x1eea <__fixunssfsi+0x42>
    1ef4:	3e f4       	brtc	.+14     	; 0x1f04 <__fixunssfsi+0x5c>
    1ef6:	90 95       	com	r25
    1ef8:	80 95       	com	r24
    1efa:	70 95       	com	r23
    1efc:	61 95       	neg	r22
    1efe:	7f 4f       	sbci	r23, 0xFF	; 255
    1f00:	8f 4f       	sbci	r24, 0xFF	; 255
    1f02:	9f 4f       	sbci	r25, 0xFF	; 255
    1f04:	08 95       	ret

00001f06 <__floatunsisf>:
    1f06:	e8 94       	clt
    1f08:	09 c0       	rjmp	.+18     	; 0x1f1c <__floatsisf+0x12>

00001f0a <__floatsisf>:
    1f0a:	97 fb       	bst	r25, 7
    1f0c:	3e f4       	brtc	.+14     	; 0x1f1c <__floatsisf+0x12>
    1f0e:	90 95       	com	r25
    1f10:	80 95       	com	r24
    1f12:	70 95       	com	r23
    1f14:	61 95       	neg	r22
    1f16:	7f 4f       	sbci	r23, 0xFF	; 255
    1f18:	8f 4f       	sbci	r24, 0xFF	; 255
    1f1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1f1c:	99 23       	and	r25, r25
    1f1e:	a9 f0       	breq	.+42     	; 0x1f4a <__floatsisf+0x40>
    1f20:	f9 2f       	mov	r31, r25
    1f22:	96 e9       	ldi	r25, 0x96	; 150
    1f24:	bb 27       	eor	r27, r27
    1f26:	93 95       	inc	r25
    1f28:	f6 95       	lsr	r31
    1f2a:	87 95       	ror	r24
    1f2c:	77 95       	ror	r23
    1f2e:	67 95       	ror	r22
    1f30:	b7 95       	ror	r27
    1f32:	f1 11       	cpse	r31, r1
    1f34:	f8 cf       	rjmp	.-16     	; 0x1f26 <__floatsisf+0x1c>
    1f36:	fa f4       	brpl	.+62     	; 0x1f76 <__floatsisf+0x6c>
    1f38:	bb 0f       	add	r27, r27
    1f3a:	11 f4       	brne	.+4      	; 0x1f40 <__floatsisf+0x36>
    1f3c:	60 ff       	sbrs	r22, 0
    1f3e:	1b c0       	rjmp	.+54     	; 0x1f76 <__floatsisf+0x6c>
    1f40:	6f 5f       	subi	r22, 0xFF	; 255
    1f42:	7f 4f       	sbci	r23, 0xFF	; 255
    1f44:	8f 4f       	sbci	r24, 0xFF	; 255
    1f46:	9f 4f       	sbci	r25, 0xFF	; 255
    1f48:	16 c0       	rjmp	.+44     	; 0x1f76 <__floatsisf+0x6c>
    1f4a:	88 23       	and	r24, r24
    1f4c:	11 f0       	breq	.+4      	; 0x1f52 <__floatsisf+0x48>
    1f4e:	96 e9       	ldi	r25, 0x96	; 150
    1f50:	11 c0       	rjmp	.+34     	; 0x1f74 <__floatsisf+0x6a>
    1f52:	77 23       	and	r23, r23
    1f54:	21 f0       	breq	.+8      	; 0x1f5e <__floatsisf+0x54>
    1f56:	9e e8       	ldi	r25, 0x8E	; 142
    1f58:	87 2f       	mov	r24, r23
    1f5a:	76 2f       	mov	r23, r22
    1f5c:	05 c0       	rjmp	.+10     	; 0x1f68 <__floatsisf+0x5e>
    1f5e:	66 23       	and	r22, r22
    1f60:	71 f0       	breq	.+28     	; 0x1f7e <__floatsisf+0x74>
    1f62:	96 e8       	ldi	r25, 0x86	; 134
    1f64:	86 2f       	mov	r24, r22
    1f66:	70 e0       	ldi	r23, 0x00	; 0
    1f68:	60 e0       	ldi	r22, 0x00	; 0
    1f6a:	2a f0       	brmi	.+10     	; 0x1f76 <__floatsisf+0x6c>
    1f6c:	9a 95       	dec	r25
    1f6e:	66 0f       	add	r22, r22
    1f70:	77 1f       	adc	r23, r23
    1f72:	88 1f       	adc	r24, r24
    1f74:	da f7       	brpl	.-10     	; 0x1f6c <__floatsisf+0x62>
    1f76:	88 0f       	add	r24, r24
    1f78:	96 95       	lsr	r25
    1f7a:	87 95       	ror	r24
    1f7c:	97 f9       	bld	r25, 7
    1f7e:	08 95       	ret

00001f80 <__fp_split3>:
    1f80:	57 fd       	sbrc	r21, 7
    1f82:	90 58       	subi	r25, 0x80	; 128
    1f84:	44 0f       	add	r20, r20
    1f86:	55 1f       	adc	r21, r21
    1f88:	59 f0       	breq	.+22     	; 0x1fa0 <__fp_splitA+0x10>
    1f8a:	5f 3f       	cpi	r21, 0xFF	; 255
    1f8c:	71 f0       	breq	.+28     	; 0x1faa <__fp_splitA+0x1a>
    1f8e:	47 95       	ror	r20

00001f90 <__fp_splitA>:
    1f90:	88 0f       	add	r24, r24
    1f92:	97 fb       	bst	r25, 7
    1f94:	99 1f       	adc	r25, r25
    1f96:	61 f0       	breq	.+24     	; 0x1fb0 <__fp_splitA+0x20>
    1f98:	9f 3f       	cpi	r25, 0xFF	; 255
    1f9a:	79 f0       	breq	.+30     	; 0x1fba <__fp_splitA+0x2a>
    1f9c:	87 95       	ror	r24
    1f9e:	08 95       	ret
    1fa0:	12 16       	cp	r1, r18
    1fa2:	13 06       	cpc	r1, r19
    1fa4:	14 06       	cpc	r1, r20
    1fa6:	55 1f       	adc	r21, r21
    1fa8:	f2 cf       	rjmp	.-28     	; 0x1f8e <__fp_split3+0xe>
    1faa:	46 95       	lsr	r20
    1fac:	f1 df       	rcall	.-30     	; 0x1f90 <__fp_splitA>
    1fae:	08 c0       	rjmp	.+16     	; 0x1fc0 <__fp_splitA+0x30>
    1fb0:	16 16       	cp	r1, r22
    1fb2:	17 06       	cpc	r1, r23
    1fb4:	18 06       	cpc	r1, r24
    1fb6:	99 1f       	adc	r25, r25
    1fb8:	f1 cf       	rjmp	.-30     	; 0x1f9c <__fp_splitA+0xc>
    1fba:	86 95       	lsr	r24
    1fbc:	71 05       	cpc	r23, r1
    1fbe:	61 05       	cpc	r22, r1
    1fc0:	08 94       	sec
    1fc2:	08 95       	ret

00001fc4 <__fp_zero>:
    1fc4:	e8 94       	clt

00001fc6 <__fp_szero>:
    1fc6:	bb 27       	eor	r27, r27
    1fc8:	66 27       	eor	r22, r22
    1fca:	77 27       	eor	r23, r23
    1fcc:	cb 01       	movw	r24, r22
    1fce:	97 f9       	bld	r25, 7
    1fd0:	08 95       	ret

00001fd2 <__mulsf3>:
    1fd2:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <__mulsf3x>
    1fd6:	0c 94 6d 10 	jmp	0x20da	; 0x20da <__fp_round>
    1fda:	0e 94 5f 10 	call	0x20be	; 0x20be <__fp_pscA>
    1fde:	38 f0       	brcs	.+14     	; 0x1fee <__mulsf3+0x1c>
    1fe0:	0e 94 66 10 	call	0x20cc	; 0x20cc <__fp_pscB>
    1fe4:	20 f0       	brcs	.+8      	; 0x1fee <__mulsf3+0x1c>
    1fe6:	95 23       	and	r25, r21
    1fe8:	11 f0       	breq	.+4      	; 0x1fee <__mulsf3+0x1c>
    1fea:	0c 94 56 10 	jmp	0x20ac	; 0x20ac <__fp_inf>
    1fee:	0c 94 5c 10 	jmp	0x20b8	; 0x20b8 <__fp_nan>
    1ff2:	11 24       	eor	r1, r1
    1ff4:	0c 94 e3 0f 	jmp	0x1fc6	; 0x1fc6 <__fp_szero>

00001ff8 <__mulsf3x>:
    1ff8:	0e 94 c0 0f 	call	0x1f80	; 0x1f80 <__fp_split3>
    1ffc:	70 f3       	brcs	.-36     	; 0x1fda <__mulsf3+0x8>

00001ffe <__mulsf3_pse>:
    1ffe:	95 9f       	mul	r25, r21
    2000:	c1 f3       	breq	.-16     	; 0x1ff2 <__mulsf3+0x20>
    2002:	95 0f       	add	r25, r21
    2004:	50 e0       	ldi	r21, 0x00	; 0
    2006:	55 1f       	adc	r21, r21
    2008:	62 9f       	mul	r22, r18
    200a:	f0 01       	movw	r30, r0
    200c:	72 9f       	mul	r23, r18
    200e:	bb 27       	eor	r27, r27
    2010:	f0 0d       	add	r31, r0
    2012:	b1 1d       	adc	r27, r1
    2014:	63 9f       	mul	r22, r19
    2016:	aa 27       	eor	r26, r26
    2018:	f0 0d       	add	r31, r0
    201a:	b1 1d       	adc	r27, r1
    201c:	aa 1f       	adc	r26, r26
    201e:	64 9f       	mul	r22, r20
    2020:	66 27       	eor	r22, r22
    2022:	b0 0d       	add	r27, r0
    2024:	a1 1d       	adc	r26, r1
    2026:	66 1f       	adc	r22, r22
    2028:	82 9f       	mul	r24, r18
    202a:	22 27       	eor	r18, r18
    202c:	b0 0d       	add	r27, r0
    202e:	a1 1d       	adc	r26, r1
    2030:	62 1f       	adc	r22, r18
    2032:	73 9f       	mul	r23, r19
    2034:	b0 0d       	add	r27, r0
    2036:	a1 1d       	adc	r26, r1
    2038:	62 1f       	adc	r22, r18
    203a:	83 9f       	mul	r24, r19
    203c:	a0 0d       	add	r26, r0
    203e:	61 1d       	adc	r22, r1
    2040:	22 1f       	adc	r18, r18
    2042:	74 9f       	mul	r23, r20
    2044:	33 27       	eor	r19, r19
    2046:	a0 0d       	add	r26, r0
    2048:	61 1d       	adc	r22, r1
    204a:	23 1f       	adc	r18, r19
    204c:	84 9f       	mul	r24, r20
    204e:	60 0d       	add	r22, r0
    2050:	21 1d       	adc	r18, r1
    2052:	82 2f       	mov	r24, r18
    2054:	76 2f       	mov	r23, r22
    2056:	6a 2f       	mov	r22, r26
    2058:	11 24       	eor	r1, r1
    205a:	9f 57       	subi	r25, 0x7F	; 127
    205c:	50 40       	sbci	r21, 0x00	; 0
    205e:	9a f0       	brmi	.+38     	; 0x2086 <__mulsf3_pse+0x88>
    2060:	f1 f0       	breq	.+60     	; 0x209e <__mulsf3_pse+0xa0>
    2062:	88 23       	and	r24, r24
    2064:	4a f0       	brmi	.+18     	; 0x2078 <__mulsf3_pse+0x7a>
    2066:	ee 0f       	add	r30, r30
    2068:	ff 1f       	adc	r31, r31
    206a:	bb 1f       	adc	r27, r27
    206c:	66 1f       	adc	r22, r22
    206e:	77 1f       	adc	r23, r23
    2070:	88 1f       	adc	r24, r24
    2072:	91 50       	subi	r25, 0x01	; 1
    2074:	50 40       	sbci	r21, 0x00	; 0
    2076:	a9 f7       	brne	.-22     	; 0x2062 <__mulsf3_pse+0x64>
    2078:	9e 3f       	cpi	r25, 0xFE	; 254
    207a:	51 05       	cpc	r21, r1
    207c:	80 f0       	brcs	.+32     	; 0x209e <__mulsf3_pse+0xa0>
    207e:	0c 94 56 10 	jmp	0x20ac	; 0x20ac <__fp_inf>
    2082:	0c 94 e3 0f 	jmp	0x1fc6	; 0x1fc6 <__fp_szero>
    2086:	5f 3f       	cpi	r21, 0xFF	; 255
    2088:	e4 f3       	brlt	.-8      	; 0x2082 <__mulsf3_pse+0x84>
    208a:	98 3e       	cpi	r25, 0xE8	; 232
    208c:	d4 f3       	brlt	.-12     	; 0x2082 <__mulsf3_pse+0x84>
    208e:	86 95       	lsr	r24
    2090:	77 95       	ror	r23
    2092:	67 95       	ror	r22
    2094:	b7 95       	ror	r27
    2096:	f7 95       	ror	r31
    2098:	e7 95       	ror	r30
    209a:	9f 5f       	subi	r25, 0xFF	; 255
    209c:	c1 f7       	brne	.-16     	; 0x208e <__mulsf3_pse+0x90>
    209e:	fe 2b       	or	r31, r30
    20a0:	88 0f       	add	r24, r24
    20a2:	91 1d       	adc	r25, r1
    20a4:	96 95       	lsr	r25
    20a6:	87 95       	ror	r24
    20a8:	97 f9       	bld	r25, 7
    20aa:	08 95       	ret

000020ac <__fp_inf>:
    20ac:	97 f9       	bld	r25, 7
    20ae:	9f 67       	ori	r25, 0x7F	; 127
    20b0:	80 e8       	ldi	r24, 0x80	; 128
    20b2:	70 e0       	ldi	r23, 0x00	; 0
    20b4:	60 e0       	ldi	r22, 0x00	; 0
    20b6:	08 95       	ret

000020b8 <__fp_nan>:
    20b8:	9f ef       	ldi	r25, 0xFF	; 255
    20ba:	80 ec       	ldi	r24, 0xC0	; 192
    20bc:	08 95       	ret

000020be <__fp_pscA>:
    20be:	00 24       	eor	r0, r0
    20c0:	0a 94       	dec	r0
    20c2:	16 16       	cp	r1, r22
    20c4:	17 06       	cpc	r1, r23
    20c6:	18 06       	cpc	r1, r24
    20c8:	09 06       	cpc	r0, r25
    20ca:	08 95       	ret

000020cc <__fp_pscB>:
    20cc:	00 24       	eor	r0, r0
    20ce:	0a 94       	dec	r0
    20d0:	12 16       	cp	r1, r18
    20d2:	13 06       	cpc	r1, r19
    20d4:	14 06       	cpc	r1, r20
    20d6:	05 06       	cpc	r0, r21
    20d8:	08 95       	ret

000020da <__fp_round>:
    20da:	09 2e       	mov	r0, r25
    20dc:	03 94       	inc	r0
    20de:	00 0c       	add	r0, r0
    20e0:	11 f4       	brne	.+4      	; 0x20e6 <__fp_round+0xc>
    20e2:	88 23       	and	r24, r24
    20e4:	52 f0       	brmi	.+20     	; 0x20fa <__fp_round+0x20>
    20e6:	bb 0f       	add	r27, r27
    20e8:	40 f4       	brcc	.+16     	; 0x20fa <__fp_round+0x20>
    20ea:	bf 2b       	or	r27, r31
    20ec:	11 f4       	brne	.+4      	; 0x20f2 <__fp_round+0x18>
    20ee:	60 ff       	sbrs	r22, 0
    20f0:	04 c0       	rjmp	.+8      	; 0x20fa <__fp_round+0x20>
    20f2:	6f 5f       	subi	r22, 0xFF	; 255
    20f4:	7f 4f       	sbci	r23, 0xFF	; 255
    20f6:	8f 4f       	sbci	r24, 0xFF	; 255
    20f8:	9f 4f       	sbci	r25, 0xFF	; 255
    20fa:	08 95       	ret

000020fc <__udivmodsi4>:
    20fc:	a1 e2       	ldi	r26, 0x21	; 33
    20fe:	1a 2e       	mov	r1, r26
    2100:	aa 1b       	sub	r26, r26
    2102:	bb 1b       	sub	r27, r27
    2104:	fd 01       	movw	r30, r26
    2106:	0d c0       	rjmp	.+26     	; 0x2122 <__udivmodsi4_ep>

00002108 <__udivmodsi4_loop>:
    2108:	aa 1f       	adc	r26, r26
    210a:	bb 1f       	adc	r27, r27
    210c:	ee 1f       	adc	r30, r30
    210e:	ff 1f       	adc	r31, r31
    2110:	a2 17       	cp	r26, r18
    2112:	b3 07       	cpc	r27, r19
    2114:	e4 07       	cpc	r30, r20
    2116:	f5 07       	cpc	r31, r21
    2118:	20 f0       	brcs	.+8      	; 0x2122 <__udivmodsi4_ep>
    211a:	a2 1b       	sub	r26, r18
    211c:	b3 0b       	sbc	r27, r19
    211e:	e4 0b       	sbc	r30, r20
    2120:	f5 0b       	sbc	r31, r21

00002122 <__udivmodsi4_ep>:
    2122:	66 1f       	adc	r22, r22
    2124:	77 1f       	adc	r23, r23
    2126:	88 1f       	adc	r24, r24
    2128:	99 1f       	adc	r25, r25
    212a:	1a 94       	dec	r1
    212c:	69 f7       	brne	.-38     	; 0x2108 <__udivmodsi4_loop>
    212e:	60 95       	com	r22
    2130:	70 95       	com	r23
    2132:	80 95       	com	r24
    2134:	90 95       	com	r25
    2136:	9b 01       	movw	r18, r22
    2138:	ac 01       	movw	r20, r24
    213a:	bd 01       	movw	r22, r26
    213c:	cf 01       	movw	r24, r30
    213e:	08 95       	ret

00002140 <__divmodsi4>:
    2140:	05 2e       	mov	r0, r21
    2142:	97 fb       	bst	r25, 7
    2144:	1e f4       	brtc	.+6      	; 0x214c <__divmodsi4+0xc>
    2146:	00 94       	com	r0
    2148:	0e 94 b7 10 	call	0x216e	; 0x216e <__negsi2>
    214c:	57 fd       	sbrc	r21, 7
    214e:	07 d0       	rcall	.+14     	; 0x215e <__divmodsi4_neg2>
    2150:	0e 94 7e 10 	call	0x20fc	; 0x20fc <__udivmodsi4>
    2154:	07 fc       	sbrc	r0, 7
    2156:	03 d0       	rcall	.+6      	; 0x215e <__divmodsi4_neg2>
    2158:	4e f4       	brtc	.+18     	; 0x216c <__divmodsi4_exit>
    215a:	0c 94 b7 10 	jmp	0x216e	; 0x216e <__negsi2>

0000215e <__divmodsi4_neg2>:
    215e:	50 95       	com	r21
    2160:	40 95       	com	r20
    2162:	30 95       	com	r19
    2164:	21 95       	neg	r18
    2166:	3f 4f       	sbci	r19, 0xFF	; 255
    2168:	4f 4f       	sbci	r20, 0xFF	; 255
    216a:	5f 4f       	sbci	r21, 0xFF	; 255

0000216c <__divmodsi4_exit>:
    216c:	08 95       	ret

0000216e <__negsi2>:
    216e:	90 95       	com	r25
    2170:	80 95       	com	r24
    2172:	70 95       	com	r23
    2174:	61 95       	neg	r22
    2176:	7f 4f       	sbci	r23, 0xFF	; 255
    2178:	8f 4f       	sbci	r24, 0xFF	; 255
    217a:	9f 4f       	sbci	r25, 0xFF	; 255
    217c:	08 95       	ret

0000217e <memcpy>:
    217e:	fb 01       	movw	r30, r22
    2180:	dc 01       	movw	r26, r24
    2182:	02 c0       	rjmp	.+4      	; 0x2188 <memcpy+0xa>
    2184:	01 90       	ld	r0, Z+
    2186:	0d 92       	st	X+, r0
    2188:	41 50       	subi	r20, 0x01	; 1
    218a:	50 40       	sbci	r21, 0x00	; 0
    218c:	d8 f7       	brcc	.-10     	; 0x2184 <memcpy+0x6>
    218e:	08 95       	ret

00002190 <memset>:
    2190:	dc 01       	movw	r26, r24
    2192:	01 c0       	rjmp	.+2      	; 0x2196 <memset+0x6>
    2194:	6d 93       	st	X+, r22
    2196:	41 50       	subi	r20, 0x01	; 1
    2198:	50 40       	sbci	r21, 0x00	; 0
    219a:	e0 f7       	brcc	.-8      	; 0x2194 <memset+0x4>
    219c:	08 95       	ret

0000219e <strncpy>:
    219e:	fb 01       	movw	r30, r22
    21a0:	dc 01       	movw	r26, r24
    21a2:	41 50       	subi	r20, 0x01	; 1
    21a4:	50 40       	sbci	r21, 0x00	; 0
    21a6:	48 f0       	brcs	.+18     	; 0x21ba <strncpy+0x1c>
    21a8:	01 90       	ld	r0, Z+
    21aa:	0d 92       	st	X+, r0
    21ac:	00 20       	and	r0, r0
    21ae:	c9 f7       	brne	.-14     	; 0x21a2 <strncpy+0x4>
    21b0:	01 c0       	rjmp	.+2      	; 0x21b4 <strncpy+0x16>
    21b2:	1d 92       	st	X+, r1
    21b4:	41 50       	subi	r20, 0x01	; 1
    21b6:	50 40       	sbci	r21, 0x00	; 0
    21b8:	e0 f7       	brcc	.-8      	; 0x21b2 <strncpy+0x14>
    21ba:	08 95       	ret

000021bc <_exit>:
    21bc:	f8 94       	cli

000021be <__stop_program>:
    21be:	ff cf       	rjmp	.-2      	; 0x21be <__stop_program>
